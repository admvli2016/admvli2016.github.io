{"pages":[],"posts":[{"title":"Electron 包装网页应用","text":"安装 Electron1.1 环境 1234567npm -v # v12.22.0node -v # 6.14.11# 操作系统：win10 1.2 安装命令 123456# 安装 electronnpm install electron -g --platform=win32# 验证安装结果electron -v # v15.2.0 创建 Electron 项目2.1 创建文件夹 ui-app-electron，并进入该文件夹 1cd D:\\ShenGuYun\\Source\\gitee\\ui-app-electron 2.2 创建 package.json 文件，内容如下 1234567891011{ &quot;name&quot;: &quot;ins-app&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;electron .&quot; }, &quot;devDependencies&quot;: { &quot;electron&quot;: &quot;^15.2.0&quot; }} 2.3 创建 main.js，内容如下： 123456789101112131415161718192021222324const {app, BrowserWindow} = require('electron')let mainWindow// 创建主窗口，设置了宽高等信息function createWindow () { mainWindow = new BrowserWindow({ width: 1000, height: 600, webPreferences: { // node集成，即是否注入node能力 nodeIntegration: true } }) // 加载主页面内容 index.html mainWindow.loadFile('index.html') mainWindow.on('closed', function () { mainWindow = null })}app.on('ready', createWindow) 2.4 创建 index.html 文件，内容如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;!-- 此title会覆盖package.json中设置的name，作为应用顶部名称 --&gt; &lt;title&gt;因思云&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello World!&lt;/body&gt;&lt;/html&gt; 运行项目12# 启动 Electron 应用npm start 封装 InS OS 网页4.1 修改 main.js 文件 123456789101112131415161718192021222324252627282930313233const {app, BrowserWindow} = require('electron')let mainWindow// 创建主窗口，设置了宽高等信息function createWindow () { mainWindow = new BrowserWindow({ // width: 1000, // height: 770, // 支持最大化 maximizable: true, // 为了让初始化窗口显示无闪烁，先关闭显示，等待加载完成后再显示。 show: false, webPreferences: { // node集成，即是否注入node能力 // nodeIntegration: true } }) // 加载主页面内容 index.html // mainWindow.loadFile('index.html') // 改为使用loadURL加载 url地址 mainWindow.loadURL('http://ins.shenguyun.com/') mainWindow.on('closed', function () { mainWindow = null }) // 自动隐藏菜单 // mainWindow.setAutoHideMenuBar(true); // 打开时最大化打开，不是全屏，保留状态栏 mainWindow.maximize(); }app.on('ready', createWindow) 4.2 重新运行项目 12# 重新启动 Electron 应用npm start 可以看到嵌进去的网页 ins.shenguyun.com/… 将该项目打包成桌面端应用5.1 安装 electron-builder 1234# 在项目文件夹下运行以下命令npm install --save-dev electron-builder# 验证安装结果node_modules/.bin/electron-builder -h 运行 node_modules/.bin/electron-builder -h 报错：Error: Cannot find module ‘fs/promises’ node.js - Cannot find module ‘fs/promises’ Electron JS - Stack Overflow 参照上述博文，将 electron-builder 版本降低到 v22.10.5 1npm install --save-dev electron-builder@22.10.5 运行 node_modules/.bin/electron-builder --version 说明安装 electron-builder 成功 5.2 打包当前项目（Windows） 123# Windows 打包成 exe 安装文件# 在 Windows 环境下执行node_modules/.bin/electron-builder -w nsis 打包过程中由于 package.json 中没有设置 repository 字段可能会报错，但不影响文件生成，忽略即可。 5.3 打包最终生成的 exe 文件在当前项目的 dist 文件夹下 设置窗口图标以及桌面快捷方式图标(12条消息) Electron设置窗口图标、设置桌面快捷方式图标_BigFamer的博客-CSDN博客_electron 窗口图标 问题：桌面快捷方式的图标格式必须大于 256x256 解决方法：使用稿定调整图片大小 【在线PS软件】在线PS图片（照片）处理工具_在线制作编辑图片ps精简版 更改后的 main.js 文件 12345678910111213141516171819202122232425262728293031323334353637const {app, BrowserWindow} = require('electron')const path = require('path')let mainWindow// 创建主窗口，设置了宽高等信息function createWindow () { mainWindow = new BrowserWindow({ // width: 1000, // height: 770, // 下面这行代码就是配置窗口图标的核心代码了 // 注意，这里的path是一个node模块哦，需要npm安装并且引入使用。最直接的作用就是拼接字符串。 icon: path.join(__dirname, './logo@20.ico'), // 支持最大化 maximizable: true, // 为了让初始化窗口显示无闪烁，先关闭显示，等待加载完成后再显示。 show: false, webPreferences: { // node集成，即是否注入node能力 // nodeIntegration: true } }) // 加载主页面内容 index.html // mainWindow.loadFile('index.html') // 改为使用loadURL加载 url 地址 mainWindow.loadURL('http://ins.shenguyun.com/') mainWindow.on('closed', function () { mainWindow = null }) // 自动隐藏菜单 // mainWindow.setAutoHideMenuBar(true); // 打开时最大化打开，不是全屏，保留状态栏 mainWindow.maximize(); }app.on('ready', createWindow) 更改后的 package.json 文件 12345678910111213141516171819202122232425262728293031{ &quot;name&quot;: &quot;InS_OS&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;electron .&quot; }, &quot;devDependencies&quot;: { &quot;electron&quot;: &quot;^15.2.0&quot;, &quot;electron-builder&quot;: &quot;^22.10.5&quot; }, &quot;author&quot;: &quot;admvli2016&quot;, &quot;repository&quot;: &quot;github:xxx/xxx&quot;, &quot;build&quot;: { &quot;win&quot;: { &quot;icon&quot;: &quot;logo.png&quot;, &quot;target&quot;: [ &quot;nsis&quot; ] }, &quot;nsis&quot;: { &quot;allowToChangeInstallationDirectory&quot;: true, &quot;oneClick&quot;: false, &quot;menuCategory&quot;: true, &quot;allowElevation&quot;: false } }, &quot;dependencies&quot;: { &quot;path&quot;: &quot;^0.12.7&quot; }} 参考博文： electron安装包里封装浏览器直接访问URL配置 码农家园 Electron入门指南 一篇文章看懂Electron封装网页并打包应用","link":"/2021/12/23/Electron-%E5%8C%85%E8%A3%85%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8/"},{"title":"Ionic5.x+Capacitor+Vue3.x 尝鲜（Android）","text":"发现 ionic 最新版本支持了 Vue3.x，于是赶紧来尝尝鲜! 环境和版本 1234Windows 10 64位node v12.22.0@ionic/cli v6.16.3Android Studio v4.2.2 创建 ionic5.x 项目1.1 创建项目，使用 Ionic 官网的快捷创建方式，生成模板代码，并将代码推到自己的 github 上 https://ionicframework.com/start#basics https://dashboard.ionicframework.com/app/1982d30d/getting-started/overview 123456# 安装 @ionic/cli 和 cordova-resnpm install -g @ionic/cli cordova-res# 拉取刚才创建的 ionic 项目git clone https://github.com/admvli2016/my-ionic-app-1.git my-ionic-app-1# 进入项目目录 &amp;&amp; 安装依赖 &amp;&amp; 运行项目cd my-ionic-app-1 &amp;&amp; npm install &amp;&amp; ionic serve Android 环境配置SDK Manager 的 Sdk 安装路径是: C:\\Users\\admvli2016\\AppData\\Local\\Android\\Sdk 2.1 下载最新版本的 Android Studio ( v4.2.2 )，然后安装 2.2 在 Android Studio 中配置 Android Sdk（更改 Android Sdk 配置后需要重新运行、打包项目） 打开 Android Studio 并按照下列步骤操作： 出现以下弹窗，点击 OK 继续 出现如下页面，安装完成后，点击 Finish 切换到 SDK Tools 选项卡 同上，出现如下页面，安装完成后，点击 Finish 在 Android Studio 中打开项目（1）123456# 安装 @capacitor/android 插件npm install @capacitor/android# 添加 android 平台npx cap add android# 在 Android Studio 中打开项目npx cap open android 运行报错：卡在这里了，只好选择重新创建项目，现在回想一下应该是没有运行 ionic build 12345Settings file 'D:\\Github\\my-ionic-app\\android\\settings.gradle' line: 5A problem occurred evaluating settings 'android'.&gt; Could not read script 'D:\\Github\\my-ionic-app\\android\\capacitor.settings.gradle' as it does not exist.......Caused by: org.gradle.api.resources.MissingResourceException: Could not read script 'D:\\Github\\my-ionic-app\\android\\capacitor.settings.gradle' as it does not exist. 以命令行形式重新创建 ionic5.x 项目执行以下命令 123456789101112131415# 安装全局依赖 @ionic/cli@latest、native-run、cordova-resnpm install -g @ionic/cli@latest native-run cordova-res# 创建项目（关闭vpn，否则会报错）ionic start ionic5-vue3-demo tabs# 运行项目ionic serve# 打包项目ionic build# 添加平台 ios/android 文件夹（本机项目）ionic cap add iosionic cap add android# 每次执行完 ionic build（有更新） 之后，都需要执行以下命令，将更改复制到本机项目ionic cap copy || ionic cap update# 对代码的本机部分进行更新（例如添加新插件）后，使用以下 sync 命令ionic cap sync 在 Android Studio 中打开项目（2）12# 打开 android 项目 ionic cap open android 系统 gradle 配置路径：C:\\Users\\admvli2016.gradle\\gradle.properties 运行报错： 原因：Android Studio 存在版本问题，老版本的 Android Studio 可能需要代理设置才能够使用，所以前几年网上关于这个问题的博文都是说需要设置代理。但是由于自己安装的是最新版本的 Android Studio，不需要代理就能够使用，所以这里也算是踩了一个坑！ (3条消息) 解决Android Studio 无法通过gradle 下载https://dl.google.com/android/repository/addons_list-3.xml 解决办法_Ansel_i的博客-CSDN博客 解决方案：关闭 VPN，删除掉所有代理设置 在 Android Studio 中打开 “设置 HTTP Proxy” 页面的快捷键 Ctrl +Alt + S 运行项目并安装到真机上6.1 在 Android Studio上选择要安装的设备 若找不到设备，选择 Troubule Shoot Device Connections，按步骤一步一步来即可找到设备 6.2 点击运行 ▸ 安装到真机上失败 123456Installation did not succeed.The application could not be installed: INSTALL_FAILED_TEST_ONLYList of apks:[0] 'D:\\Github\\ionic5-vue3-demo\\android\\app\\build\\outputs\\apk\\debug\\app-debug.apk'Installation failed due to: 'null' (3条消息) Android 安装APP 失败 INSTALL_FAILED_TEST_ONLY_爱孔孟-CSDN博客 解决方案：在 gradle.properties 文件中添加如下内容 1android.injected.testOnly=false 重新运行，安装到真机成功！！！ 在 Android Studio 中将程序打包成 APK(3条消息) 在Android Studio中如何将程序打包成APK_StevenAzy的博客-CSDN博客_android studio怎么打包成apk 在 Android Studio 中打开项目，按照下列步骤进行操作 如果之前有编译成 APK 的话，就直接选择 Choose existing key 如果没有编译成 APK 的， 那就选择 Create new key 选择新的 key 的存放路径，点击 OK 继续 填上密码，其中 First and Last Name 填一下，其他的可不填。 点击 OK 继续下一步 点击 Next 继续下一步（这一步不能够记住密码，否则可能会导致之后 build 报错） 点击 Finish，最终生成的 APK 文件就在下图所示的路径中 打包成功！！！ 注意：再次打包时需要将之前打包生成的 release 或 debug 文件夹删除，才能看到效果","link":"/2021/12/10/Ionic5-x-Capacitor-Vue3-x-%E5%B0%9D%E9%B2%9C%EF%BC%88Android%EF%BC%89/"},{"title":"Ionic5.x+Capacitor+Vue3.x 集成极光推送（Android）","text":"安装 cordova-plugin-jpush-capacitor12345# 安装 cordova-plugin-jpush-capacitornpm i cordova-plugin-jpush-capacitor # 同步至 ios / android 平台ionic cap sync 报缺少依赖错误： 123cordova-plugin-jpush-capacitor is missing dependencies:[capacitor] - cordova-plugin-device[capacitor] - cordova-plugin-jcore 安装 cordova-plugin-device，运行如下命令： 12npm install cordova-plugin-deviceionic cap sync 安装 cordova-plugin-jcore，运行如下命令： 12npm install cordova-plugin-jcore ionic cap sync 查看插件列表： 1npx cap ls 更改 appId 和 appName修改下列文件中的 appId 和 appName 12345678// ionic.config.json{ &quot;name&quot;: &quot;因思工业服务&quot;, &quot;integrations&quot;: { &quot;capacitor&quot;: {} }, &quot;type&quot;: &quot;vue&quot;} 1234567// capacitor.config.json{ &quot;appId&quot;: &quot;com.ionicframework.xxxxxx&quot;, &quot;appName&quot;: &quot;因思工业服务&quot;, &quot;webDir&quot;: &quot;dist&quot;, &quot;bundledWebRuntime&quot;: false} 删除 android 和 ios platform 后重新添加再打包（避免缓存） 12345678910111213141516# 安装 rimrafnpm install -g rimraf# 删除 android 文件夹rimraf android# 删除 ios 文件夹rimraf ios# 添加 android 平台npx cap add android# 添加 ios 平台npx cap add ios# 打包ionic build# 同步至 ios / android 平台ionic cap sync# 在 Android Studio 中打开项目ionic cap open android 在 AndroidManifest.xml 文件中添加极光推送的 AppKey极光后台：https://www.jiguang.cn/portal/#/dev/ 可在极光开发者服务后台 &gt; 应用管理 &gt; 应用设置 &gt; 应用信息中查看 AppKey 不要忘记在 gradle.properties 文件中添加： 1android.injected.testOnly=false 添加示例程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546// src/utils/jpush.tsimport { isPlatform } from '@ionic/vue'; class Jpush { jpush: any; constructor() { if (window.JPush) { this.jpush = window.JPush; this.jpush.setDebugMode(true); if (isPlatform('ios')) { this.jpush.startJPushSDK(); } this.jpush.init(); } } getRegistrationID() { return new Promise(resolve =&gt; { this.jpush.getRegistrationID(function (rId: string) { resolve(rId); // console.log(&quot;JPushPlugin:registrationID is &quot; + rId); }) }) } // 设置别名 setAlias(alias: string) { return new Promise(((resolve, reject) =&gt; { this.jpush.setAlias({ alias, sequence: new Date().valueOf() }, (res: { alias: string; sequence: number }) =&gt; { // console.log('别名设置成功: ', res); resolve(res); }, (err: { code: number; sequence: number }) =&gt; { // console.log('别名设置失败: ', err); setTimeout(() =&gt; this.setAlias(alias), 3000); reject(err); }); })) } // 设置角标 只限IOS setBadge(badge: number) { if (isPlatform('ios')) { this.jpush.setBadge(badge); } }}export default Jpush 12345678910111213141516171819202122232425262728293031&lt;!-- App.vue --&gt;&lt;template&gt; &lt;ion-app&gt; &lt;ion-router-outlet /&gt; &lt;/ion-app&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { Plugins } from &quot;@capacitor/core&quot;;import { defineComponent, onMounted } from 'vue';import { IonApp, IonRouterOutlet } from '@ionic/vue';import jpush from &quot;@/utils/jpush&quot;;const { SplashScreen } = Plugins;export default defineComponent({ name: 'App', components: { IonApp, IonRouterOutlet }, setup() { onMounted(() =&gt; { // 由于是cordova插件，需要在deviceready回调后才能使用，用过Cordova的都懂 document.addEventListener('deviceready', () =&gt; { new jpush().setAlias('app'); }) setTimeout(() =&gt; SplashScreen.hide(), 2000); }) }});&lt;/script&gt; 极光后台模拟推送通知极光后台：https://www.jiguang.cn/portal/#/dev/ 5.1 创建推送信息 设置平台、标题、内容、发送时间 5.2 选择发送给哪些人 5.3 发送推送消息 5.4 确认发送 5.5 在 App 上查看是否收到推送通知 测试极光推送是否集成成功重新打包，在 Android Studio 中运行项目并将其安装到手机上 每次重新打包之后都需要去配置极光插件的 AppKey，之前的配置将会被清除 在安装过程中，Android Studio 控制台报错： 原因是没有给 App 授予通知权限（记住一定要给 App 授予通知权限） 授予通知权限后，在极光后台上模拟推送一条通知，发现手机上还是接收不到 极光后台报错提示如下： 可能是因为此时设置的设备别名（alias）有问题，将其改为自己的用户ID 190395486111268864 12345// App.vuedocument.addEventListener('deviceready', () =&gt; { // 设置为 190395486111268864 new jpush().setAlias('190395486111268864');}) 重新打包并安装到手机上（需要将之前安装的 APP 删掉），记得授予通知权限 如下图所示，极光推送集成成功！！！ 测试 App(Android) 处于不同状态时的推送机制 Android（Demo） 前台模式 后台模式 关闭 是否推送 推送 不推送 不推送 Android（线上App） 前台模式 后台模式 关闭 是否推送 推送 推送 不推送 怎么让 Demo 进入后台模式也可进行推送发现将 AndroidManifest.xml 中的配置放在 capacitor-cordova-android-plugins 文件夹中，App 进入后台模式就接收不到推送；而将其放到 app 文件夹中，进入后台模式也可接收到推送 1234567&lt;!-- app/manifests/AndroidManifest.xml --&gt;&lt;!-- 将极光推送配置粘贴到 &lt;/application&gt; --&gt;&lt;application&gt;...&lt;meta-data android:name=&quot;JPUSH_CHANNEL&quot; android:value=&quot;developer-default&quot;/&gt;&lt;meta-data android:name=&quot;JPUSH_APPKEY&quot; android:value=&quot;AppKey&quot;/&gt;&lt;/application&gt; 12345&lt;!-- capacitor-cordova-android-plugins/manifests/AndroidManifest.xml --&gt;&lt;!-- 删除掉下面两句这里每次运行 ionic cap sync 时，都会重新生成，所以在打包之前需要检查下，否则 ionic build 会报错 --&gt;&lt;meta-data android:name=&quot;JPUSH_CHANNEL&quot; android:value=&quot;developer-default&quot;/&gt;&lt;meta-data android:name=&quot;JPUSH_APPKEY&quot; android:value=&quot;AppKey&quot;/&gt; 参考博文： ionic快速集成极光推送 · dicallc/ionic3_angular4_JD Wiki","link":"/2021/12/11/Ionic5-x-Capacitor-Vue3-x-%E9%9B%86%E6%88%90%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%EF%BC%88Android%EF%BC%89/"},{"title":"Mac 使用时间机器备份","text":"参照下述博文，首先使用 ”时间机器“ 备份 Mac 必须要有一个外置的储存设备。 如何备份 Mac - 官方 Apple 支持 使用“时间机器”备份您的 Mac - Apple 支持 (中国) 可与“时间机器”搭配使用的备份磁盘 - Apple 支持 (中国) 我尝试了两种备份方案：（1）备份到 smb 网络硬盘 （2）备份到移动硬盘 下面分别介绍一下操作步骤 备份到 smb 网络硬盘smb 网络硬盘也就是 windows 共享文件夹 参考博文：添加Mac的Time Machine备份到smb网络硬盘（windows 共享文件夹） 1.1 首先打开 “磁盘工具” 如何在 Mac 中打开 “磁盘工具” ？参照下面的博文 如何使用Mac的磁盘实用程序进行分区，擦除，修复，还原和复制驱动器-howtoip.com在线科技杂志 Command + 空格 &gt; 输入 Disk Utility 1.2 在 “磁盘工具” 中，移到最上面的菜单栏，选择文件 &gt; 新建映像 &gt; 空白映像 1.3 在弹出来的配置窗口中，填入如下信息。注意选择映像格式为 “稀疏磁盘映像”，设置大小为1TB。名称可以自己设定，最好不要用中文，支持空格，但后面配置命令行的时候要注意路径。配置完之后，点击 “存储”。 1.4 点击存储后，大概几十秒钟的样子，就创建成功了。这个时候，你可以在 “文稿” 中看到这个镜像 “backup.sparseimage”，并且在 finder 中，应该能看到已经挂载了该镜像。如果挂载了，先退出这个镜像。没有的话，就忽略该步骤。 1.5 将 backup.sparseimage 通过网络拷贝到 smb 网络硬盘（Windows 共享文件夹）下，然后双击打开它。接下来，你可以在设备列表中看见 “backup” 挂载。如果没有看到，可以点击 ”xxx的Macbook Pro“ ，查看该镜像是否在列表中，在的话，可以拖出来到左边的设备列表中。 如何在 Mac 中访问 Windows 共享文件夹？参照下面的博文 Mac OS X 访问 Windows共享文件夹 - 简书 点击访达菜单中的 前往 &gt; 前往服务器 1.6 接下来，打开终端，输入以下命令 1sudo tmutil setdestination -p /Volumes/backup/ 如何在 Mac 中打开终端？参照下面的博文 (12条消息) mac启动terminal终端快捷键_彭世瑜的博客-CSDN博客_mac打开命令行快捷键 Command + 空格 &gt; 输入 terminal 如果之前的名称中有空格，在输入的时候切记要加上\\, 比如取得名字是 mac backup，那么上面的backup 的路径是 mac\\ backup。 过程中出现如下报错： 1234tmutil: setdestination requires Full Disk Access privileges.To allow this operation, select Full Disk Access in the Privacy tab of the Security &amp; Privacy preference pane, and add Terminal to the list of applications which are allowed Full Disk Access.# tmutil:setdestination 需要完全磁盘访问权限。要允许此操作，请在“安全性与隐私”菜单中选择“完全磁盘访问”选项卡，并添加 Terminal 到允许完全访问磁盘的应用程序列表中。 如何在 Mac 中打开 ”安全性与隐私“？参照下面的博文 更改 Mac 上“安全性与隐私”中的“通用”偏好设置 - Apple 支持 苹果菜单 &gt; 系统偏好设置 &gt; 点击安全性与隐私 如何在 Mac 中启用完整磁盘访问权限？参照下面的博文 在 macOS Mojave 中启用完整磁盘访问 – Intego 支持 （1）打开 ”安全性与隐私“ 窗口，并选择 “隐私” 选项卡 （2）在左侧列表中选择 ”完整磁盘访问“ （3）点击左下角的锁图标，解锁界面 （4）输入您的 Mac 管理员密码 （5）将 Terminal 应用程序的图标拖放到右侧的列表中，如上图所示 1.7 成功后，打开 Time Machine 设置，就能看到 backup 磁盘了。勾上 “自动备份” 选项以及 “在菜单栏中显示 Time Machine”。 1.8 接下来在桌面菜单栏中，可以看到 Time Machine 图标。点击选择立即备份，就可以了。 基本的设置就是这样。这样的备份只是一种非常规的Time Machine使用，基于现有的条件使用。这种备份没办法解决系统崩溃无法开机的情况。还是建议定期使用移动硬盘作备份，并且妥善保管之。另外，在我之前的使用中，出现了网络临时断开后备份报错，到后面怎么也无法再次备份的情况，只能删掉挂载的分区重新建立，所以，这种情况还会带来这种无法预知的问题。大家用的时候还是要慎重。 备份到移动硬盘参考博文： 使用“时间机器”备份您的 Mac - Apple 支持 (中国) 要使用“时间机器”创建备份，您只需一个外置储存设备。连接储存设备并选择它作为您的备份磁盘后，“时间机器”会自动制作过去 24 小时的每小时备份、过去一个月的每天备份以及之前所有月份的每周备份。如果备份磁盘已满，则最早的备份会被删除。 2.1 连接外置储存设备 连接以下其中一种外置储存设备 连接到 Mac 的外置驱动器，例如 USB 或雷雳驱动器 支持通过 SMB 进行“时间机器”备份的联网储存 (NAS) 设备 共享为“时间机器”备份目标位置的 Mac AirPort 时间返回舱，或连接到 AirPort 时间返回舱或 AirPort Extreme 基站 (802.11ac) 的外置驱动器 2.2 选择您的储存设备作为备份磁盘 2.2.1 打开时间机器 苹果菜单 &gt; 系统偏好设置 &gt; 点按 ”时间机器“ 2.2.2 点按 ”选择备份磁盘“ 2.2.3 从可用磁盘列表中选择您的备份磁盘。为了使您的备份仅供拥有备份密码的用户访问，您可以选择 “加密备份”。然后点按 “使用磁盘”： 如果您选择的磁盘没有按照 “时间机器” 的要求进行格式化，系统会提示您先抹掉磁盘。点按 “抹掉” 以继续操作。这样操作会抹掉备份磁盘上的所有信息。 如何在 Mac 上格式化磁盘？参照下面的博文 在 Mac 上的“磁盘工具”中抹掉并重新格式化储存设备 - Apple 支持 文件系统格式必须为 “Mac OS 扩展” 2.3 享受自动备份带来的便利 选择备份磁盘后，“时间机器” 会立即开始自动定期备份，无需您进行进一步操作。首次备份可能需要很长时间，但您可以在进行备份时继续使用 Mac。“时间机器” 只会备份自上次备份以来有变动的文件，因此将来的备份速度会加快。 要手动启动备份，请在菜单栏的 “时间机器” 菜单中选择 “立即备份”。使用这个菜单，还可以查看某一备份的状态或跳过正在进行的某一备份。 使用时间机器恢复 Mac 备份参考博文： 从备份恢复 Mac - Apple 支持 (中国) 在 Mac 上恢复使用时间机器备份的项目 - Apple 支持 3.1 在 Mac 上，打开想要恢复项目的窗口。 例如，若要恢复意外从 “文稿” 文件夹中删除的文件，请打开 “文稿” 文件夹。 如果丢失了桌面上的项目，则无需打开窗口。 3.2 打开时间机器。当您的 Mac 连接到备份磁盘时，可能会出现一条信息。 点按菜单栏中的时间机器图标 ，然后选取“进入时间机器”，也可以打开时间机器。如果菜单栏中没有时间机器图标，请选取苹果菜单 &gt;“系统偏好设置”，点按“时间机器” ，然后选择“在菜单栏中显示时间机器”。 3.3 使用箭头和时间线浏览本地快照和备份。 如果看到脉冲光线到半暗灰色刻度标记，则表示仍在将备份载入备份磁盘或者仍在验证。 3.4 选择要恢复的一个或多个项目（其中可以包括文件夹或整个磁盘），然后点按“恢复”。 恢复的项目将返回到其原始位置。例如，如果某个项目在“文稿”文件夹中，它将返回“文稿”文件夹。","link":"/2021/12/23/Mac-%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8%E5%A4%87%E4%BB%BD/"},{"title":"React Native 0.66 Demo 集成 Code Push（Android）","text":"安装 App Center CLI1234# 安装 App Center CLInpm install -g appcenter-cli# 登录 App Centerappcenter login 在 App Center CLI 中创建应用并生成部署密钥12345678910111213141516171819# 使用 appcenter cli 在 appcenter 中创建两个 app 应用appcenter apps create -d MyReactNativeDemo-Android -o Android -p React-Nativeappcenter apps create -d MyReactNativeDemo-iOS -o iOS -p React-Native# 查看 appcenter 中创建的应用appcenter apps list# 设置当前操作的应用appcenter apps set-current 3148441341-qq.com/MyReactNativeDemo-Android# 查看当前操作的应用appcenter apps get-current# 创建两个部署（ Staging 和 Production ）appcenter codepush deployment add Staging appcenter codepush deployment add Production# 查看两个部署的部署密钥appcenter codepush deployment list --displayKeys 当前 React Native App Demo 应用的两个部署的部署密钥 集成 Code Push 插件安装 react-native-code-push1234# 进入项目文件夹cd MyReactNativeDemo# 安装 react-native-code-pushnpm install --save react-native-code-push 项目配置（1）在 android/settings.gradle 文件中添加以下内容 12include ':app', ':react-native-code-push'project(':react-native-code-push').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-code-push/android/app') （2）在 android/app/build.gradle 文件中添加以下内容，注意顺序 1234...apply from: &quot;../../node_modules/react-native/react.gradle&quot;apply from: &quot;../../node_modules/react-native-code-push/android/codepush.gradle&quot;... （3）在 MainApplication.java 文件中进行如下修改 文件路径：android\\app\\src\\main\\java\\com\\myreactnativedemo\\MainApplication.java 123456789101112131415...// 1. Import the plugin class.import com.microsoft.codepush.react.CodePush;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { ... // 2. Override the getJSBundleFile method to let // the CodePush runtime determine where to get the JS // bundle location from on each app start @Override protected String getJSBundleFile() { return CodePush.getJSBundleFile(); } };} （4）将部署密钥添加到 strings.xml 文件路径：android\\app\\src\\main\\res\\values\\strings.xml 这里直接使用 Production: A1A3V3vVS0seesi2d8b1e13NVo2ftPx1Xb23q 12345&lt;!-- android\\app\\src\\main\\res\\values\\strings.xml --&gt;&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;MyReactNativeDemo&lt;/string&gt; &lt;string moduleConfig=&quot;true&quot; name=&quot;CodePushDeploymentKey&quot;&gt;A1A3V3vVS0seesi2d8b1e13NVo2ftPx1Xb23q&lt;/string&gt;&lt;/resources&gt; 代码签名设置（可选）使用 App Center CLI 发布 CodePush 更新 - Visual Studio App Center 微软文档 不影响热更新正常使用。 自定义配置（多部署测试）将 React Native SDK 与 CodePush 结合使用 - 分发 - Visual Studio 应用中心 微软文档 打开 android/app/build.gradle 文件，进行以下修改 12345678910111213141516171819202122232425android { ... buildTypes { debug { ... // Note: CodePush updates shouldn't be tested in Debug mode as they're overriden by the RN packager. However, because CodePush checks for updates in all modes, we must supply a key. resValue &quot;string&quot;, &quot;CodePushDeploymentKey&quot;, '&quot;&quot;' ... } releaseStaging { ... resValue &quot;string&quot;, &quot;CodePushDeploymentKey&quot;, '&quot;wAOCubam2DmxXVUdldVFkAjKPuzIU7zz2k8A1&quot;' // Note: It's a good idea to provide matchingFallbacks for the new buildType you create to prevent build issues // Add the following line if not already there matchingFallbacks = ['release'] ... } release { ... resValue &quot;string&quot;, &quot;CodePushDeploymentKey&quot;, '&quot;A1A3V3vVS0seesi2d8b1e13NVo2ftPx1Xb23q&quot;' ... } } ...} 配置如下图所示 记得要注释掉 3.2 中strings.xml 的配置 123456&lt;!-- android\\app\\src\\main\\res\\values\\strings.xml --&gt;&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;MyReactNativeDemo&lt;/string&gt; &lt;!-- &lt;string moduleConfig=&quot;true&quot; name=&quot;CodePushDeploymentKey&quot;&gt;A1A3V3vVS0seesi2d8b1e13NVo2ftPx1Xb23q&lt;/string&gt; --&gt;&lt;/resources&gt; 在项目中使用 react-native-code-pushReact Native Client SDK 插件使用 - Visual Studio App Center 微软文档 使用 CodePush API 参考 React Native SDK - Visual Studio 应用中心 微软文档 React Native 集成 CodePush 指南 - 掘金 参照上述文章 123456789101112131415161718192021222324252627282930313233343536373839404142// App.jsimport React from 'react';import {View, StyleSheet} from 'react-native';import codePush from 'react-native-code-push';import AwesomeButton from 'react-native-really-awesome-button';const codePushOptions = {checkFrequency: codePush.CheckFrequency.MANUAL};const App = () =&gt; { const checkForUpdate = () =&gt; { codePush.sync({ updateDialog: true, installMode: codePush.InstallMode.IMMEDIATE, }); }; const clear = () =&gt; { codePush.clearUpdates(); }; return ( &lt;View&gt; &lt;AwesomeButton type=&quot;secondary&quot; onPress={checkForUpdate}&gt; 检查更新 &lt;/AwesomeButton&gt; &lt;AwesomeButton type=&quot;secondary&quot; onPress={clear}&gt; 清除更新 &lt;/AwesomeButton&gt; &lt;/View&gt; );};const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', },});// 注意：这是可选的，完全可以不使用 codePush 这里包装export default codePush(codePushOptions)(App); 安装 react-native-really-awesome-button 12# 安装 react-native-really-awesome-buttonnpm install --save react-native-really-awesome-button 发布更新发布更新 - Visual Studio 应用中心 微软文档 使用 appcenter cli 发布更新， 在此之前通过 appcenter login 登录 App Center。 123456# 发布更新-原命令appcenter codepush release-react -a &lt;ownerName&gt;/&lt;appName&gt;# 设置当前操作的应用之后appcenter codepush release-react# 可以添加发布描述appcenter codepush release-react -m --description &quot;第一次热更新&quot; （1）打包应用 1234# 打开 android 文件夹cd android# 打包 release 应用./gradlew assembleRelease 打包失败 猜测是因为 android\\settings.gradle 的配置问题，更改配置如下： 再次尝试打包，还是失败。 猜测是因为 android\\app\\build.gradle 的配置问题，更改配置如下： 再次尝试打包 打包成功，确实是 android\\app\\build.gradle 的配置问题，只引入下面的文件即可，不必和文档上一样引入两个文件。 （2）发布第一次更新 1234# 进入项目文件夹cd D:\\ShenGuYun\\Source\\gitee\\MyReactNativeDemo# 发布更新appcenter codepush release-react -m --description &quot;第一次热更新&quot; 发现发布的是 Staging 模式部署，升级发布 Production 模式部署 1234# 原命令appcenter codepush promote -a &lt;ownerName&gt;/MyApp -s Staging -d Production# 简化之后appcenter codepush promote -s Staging -d Production 成功发布!!! （3）在手机上查看（检查更新）是否有更新 确实有更新提示 点击 CONTINUE 手机会自动应用最新的热更新包，并刷新页面。 （4）修改 App.js 代码，应用打包，再次发布更新 执行热更新命令 12appcenter codepush release-react -m --description &quot;第二次热更新&quot;appcenter codepush promote -s Staging -d Production 应用热更新之前 应用热更新之后 集成 Code Push 成功 !!! 参考博文： 使用 CodePush 实时更新您的应用程序 - Visual Studio App Center 微软文档 React Native Client SDK 入门 - Visual Studio App Center 微软文档 Ionic5.x+Capacitor+Vue3.x 集成 Code Push（Android） - Admvli2016’s Blog","link":"/2021/12/24/React-Native-0-66-Demo-%E9%9B%86%E6%88%90-Code-Push%EF%BC%88Android%EF%BC%89/"},{"title":"React Native 0.66 Demo 集成 Code Push（iOS）","text":"安装 App Center CLI打开终端执行以下命令： 1234# 安装 App Center CLInpm install -g appcenter-cli# 登录 App Centerappcenter login 在 App Center CLI 中创建应用并生成部署密钥React Native 0.66 Demo 集成 Code Push（Android） - Admvli2016’s Blog 参见上述博文，之前在进行 Android 平台 Demo 构建时，已经创建好了应用，现在只需要将当前操作的应用设置为 MyReactNativeDemo-iOS 即可。 12# 查看 appcenter 中创建的应用appcenter apps list 123456789# 查看当前操作的应用appcenter apps get-current# 设置当前操作的应用appcenter apps set-current 3148441341-qq.com/MyReactNativeDemo-iOS# 创建两个部署（Staging 和 Production）appcenter codepush deployment add Stagingappcenter codepush deployment add Production# 查看两个部署的部署密钥appcenter codepush deployment list --displayKeys 当前 React Native App Demo 应用的两个部署的部署密钥 集成 Code Push 插件安装 react-native-code-push1234# 进入项目目录cd Documents/MyReactNativeDemo# 安装 react-native-code-pushnpm install --save react-native-code-push 项目配置（1）运行以下命令安装所有必要的 CocoaPods 依赖项。（需要打开 VPN） 12# 安装 CocoaPods 依赖项cd ios &amp;&amp; pod install &amp;&amp; cd .. （2）打开 AppDelegate.m 文件，并添加如下内容 文件路径：ios/MyReactNativeDemo/AppDelegate.m 1#import &lt;CodePush/CodePush.h&gt; （3）同样是在 AppDelegate.m 文件，找到以下代码行（用于为生产版本设置 bridge 的源 URL）： 1return [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;]; 将其替换为以下代码： 1return [CodePush bundleURL]; （4）将部署密钥添加到 Info.plist 文件中 文件路径：ios/MyReactNativeDemo/Info.plist 这里直接使用 Production: sKXbaBk46P7ito0QKuWKDa4r6B8aONFQccL8_ 123&lt;!-- ios/MyReactNativeDemo/Info.plist --&gt;&lt;key&gt;CodePushDeploymentKey&lt;/key&gt;&lt;string&gt;sKXbaBk46P7ito0QKuWKDa4r6B8aONFQccL8_&lt;/string&gt; HTTP 异常域配置同样是在 Info.plist 文件，进行如下修改 12345678910111213141516&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;!-- ...other configs... --&gt; &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;codepush.appcenter.ms&lt;/key&gt; &lt;dict&gt;&lt;!-- read the ATS Apple Docs for available options --&gt;&lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;!-- ...other configs... --&gt; &lt;/dict&gt;&lt;/plist&gt; 代码签名设置（可选）React Native客户端 SDK 入门 - Visual Studio App Center Microsoft Docs 不影响热更新正常使用。 自定义配置（多部署测试）Using the React Native SDK with CodePush – Distribution - Visual Studio App Center Microsoft Docs （1）用 Xcode 打开项目 （2）如图所示，选中 Info 选项卡 （3）如图所示，点击 Configurations 部分的 + 按钮，然后选择 Duplicate &quot;Release&quot; （4）将新出现的配置项命名为 Staging （5）然后切换到 Build Settings 选项卡，点击工具栏上的 + 按钮，选择 Add User-Defined Setting 将新出现的配置项命名为 MULTI_DEPLOYMENT_CONFIG，然后给其设置值。 Release 设置为 $(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME) Staging 设置为 $(BUILD_DIR)/Release$(EFFECTIVE_PLATFORM_NAME) 配置结果如下图所示： （6）再次点击工具栏上面的 + 按钮，选择 Add User-Defined Setting 将新出现的配置项命名为 CODEPUSH_KEY，然后给其设置值。 Release 设置为 sKXbaBk46P7ito0QKuWKDa4r6B8aONFQccL8_ Staging 设置为 pnXIXQ4NPcCT3YOAm_a05xp5u8oJbdWtK4JHH （7）打开 Info.plist 文件，将 CodePushDeploymentKey 值改为 $(CODEPUSH_KEY) 文件路径：ios/MyReactNativeDemo/Info.plist 123&lt;!-- ios/MyReactNativeDemo/Info.plist --&gt;&lt;key&gt;CodePushDeploymentKey&lt;/key&gt;&lt;string&gt;$(CODEPUSH_KEY)&lt;/string&gt; 在项目中使用 react-native-code-pushReact Native 0.66 Demo 集成 Code Push（Android） - Admvli2016’s Blog React Native 集成 CodePush 指南 - 掘金 参照上述文章 1234567891011121314151617181920212223242526272829303132333435363738394041import React from 'react';import {View, StyleSheet} from 'react-native';import codePush from 'react-native-code-push';import AwesomeButton from 'react-native-really-awesome-button';const codePushOptions = {checkFrequency: codePush.CheckFrequency.MANUAL};const App = () =&gt; { const checkForUpdate = () =&gt; { codePush.sync({ updateDialog: true, installMode: codePush.InstallMode.IMMEDIATE, }); }; const clear = () =&gt; { codePush.clearUpdates(); }; return ( &lt;View style={styles.container}&gt; &lt;AwesomeButton type=&quot;secondary&quot; onPress={checkForUpdate}&gt; 检查更新 &lt;/AwesomeButton&gt; &lt;AwesomeButton type=&quot;secondary&quot; onPress={clear}&gt; 清除更新 &lt;/AwesomeButton&gt; &lt;/View&gt; );};const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', },});// 注意：这是可选的，完全可以不使用 codePush 这里包装export default codePush(codePushOptions)(App); 安装 react-native-really-awesome-button 12# 安装 react-native-really-awesome-buttonnpm install --save react-native-really-awesome-button 发布更新（1）打包应用 1234# 进入项目目录cd Documents/MyReactNativeDemo# 打包应用npx react-native run-ios --configuration Release 打包应用，尝试将应用安装到模拟器时报错： Google 了一下 xcode - Build error domain=com.apple.CoreSimulator.SimError, code=405 - Stack Overflow 参照上述博文，清理掉 Xcode 的项目构建数据和索引。 操作路径：苹果菜单 &gt; 关于本机 &gt; 选择储存空间 &gt; 打开管理 &gt; 选择开发者 &gt; 删除项目构建数据和索引 重新打包应用，运行 npx react-native run-ios --configuration Release 还是报错： 还是在之前的界面，清理掉 Xcode 缓存，重新打包，尝试有没有效果。 还是报错： 尝试在 Debug 模式（是指命令行命令）下运行，验证是不是发布模式不允许在模拟器上安装？ 执行 npx react-native run-ios 试了还是报错。 尝试指定模拟器运行，执行 npx react-native run-ios --simulator=&quot;iPhone 11&quot; 还是报错。 尝试在执行下面的命令之后，再执行 npx react-native run-ios 12# 重启所有模拟器sudo xcrun simctl shutdown all &amp;&amp; sudo xcrun simctl erase all 还是报错。 尝试清空开发者页面 Xcode 的所有缓存，包括项目归档。再执行 npx react-native run-ios 。 还是报错。 可能是在配置 ”release scheme” 时将下拉的 Build Configuration 设置为了 Release 的缘故，将其改为 Debug，再次尝试。 还是报错。没有其他办法了，暂时放弃，使用 Xcode 来进行应用打包。 React Native 0.66 Demo 集成 Code Push（Android） - Admvli2016’s Blog 参照上述博文中的 5.5、5.6 步骤，打包成功！ 然后参照 5.7 内测分发步骤，将打包好的应用安装到手机上。 （2）发布第一次更新 123456# 进入项目文件夹cd Documents/MyReactNativeDemo# 发布更新（Staging 模式部署）appcenter codepush release-react -m --description &quot;第一次热更新&quot;# 升级至 Production 模式部署appcenter codepush promote -s Staging -d Production 发布成功!!! （3）在手机上查看（检查更新）是否有更新 在手机上点击“检查更新”按钮，没有看到更新的弹窗。 更改 App.js 123456789&lt;View style={styles.container}&gt; &lt;AwesomeButton type=&quot;secondary&quot; onPress={checkForUpdate}&gt; 检查更新 &lt;/AwesomeButton&gt; &lt;!--添加“清除更新”按钮--&gt; &lt;AwesomeButton type=&quot;secondary&quot; onPress={clear}&gt; 清除更新 &lt;/AwesomeButton&gt;&lt;/View&gt; 通过内测分发安装打包好的应用，然后再次发布热更新。 12# 发布更新（Staging 模式部署）appcenter codepush release-react -m --description &quot;第二次热更新&quot; 在手机上点击“检查更新”按钮，没有看到更新弹窗。 升级至 Production 模式部署 12# 升级至 Production 模式部署appcenter codepush promote -s Staging -d Production 在手机上再次点击“检查更新”按钮 ，可以看到有更新弹窗 点击 Continue 完成热更新之后，可以看到按钮居中了。 集成 Code Push 成功 !!! 参考博文： 使用 CodePush 更新应用程序 - Visual Studio App Center Microsoft Docs React Native客户端 SDK 入门 - Visual Studio App Center Microsoft Docs Ionic5.x+Capacitor+Vue3.x 集成 Code Push（Android） - Admvli2016’s Blog React Native 0.66 Demo 集成 Code Push（Android） - Admvli2016’s Blog","link":"/2021/12/26/React-Native-0-66-Demo-%E9%9B%86%E6%88%90-Code-Push%EF%BC%88iOS%EF%BC%89/"},{"title":"React-Native 0.66 Demo 集成极光推送（Android）","text":"当前 Demo 的 AppId 是 com.myreactnativedemo，公司已有项目（开通了极光推送服务）的 AppId 为 com.xxxxxxx.xxxxxx 参照 React Native 0.66 Demo 搭建全过程（Android） - Admvli2016’s Blog 重新创建项目设置 AppId 为 com.xxxxxxx.xxxxxx 1npx react-native init com.xxxxxxx.xxxxxx 创建失败。 改变策略，先尝试集成极光推送插件，若无法集成，再尝试参照下述博文更改 AppId (包名) 在React Native中更改Android的软件包名称 安装 jcore-react-native 、jpush-react-nativejpush/jpush-react-native: JPush’s officially supported React Native plugin (Android &amp; iOS). 极光推送官方支持的 React Native 插件（Android &amp; iOS）。 参照官方文档 1234# 安装 jcore-react-nativenpm install --save jcore-react-native# 安装 jpush-react-nativenpm install --save jpush-react-native 安装完成后连接原生库，进入项目目录执行 12npx react-native link jpush-react-nativenpx react-native link jcore-react-native 项目配置（1）android\\app\\build.gradle 添加如下内容： 12345678910111213android { defaultConfig { // 在此替换你的应用包名 applicationId &quot;com.xxxxxxx.xxxxxx&quot; ... manifestPlaceholders = [ // 在此替换你的 APPKey JPUSH_APPKEY: &quot;xxxxxxxx&quot;, // 在此替换你的 channel JPUSH_CHANNEL: &quot;developer-default&quot; ] }} 1234567dependencies { ... // 添加 jpush 依赖 implementation project(':jpush-react-native') // 添加 jcore 依赖 implementation project(':jcore-react-native') } 这里的 applicationId 设置为已开通极光推送服务的 AppId – com.xxxxxxx.xxxxxx，尝试是否能接收到推送。 （2）android\\settings.gradle 添加如下内容： 1234include ':jpush-react-native'project(':jpush-react-native').projectDir = new File(rootProject.projectDir, '../node_modules/jpush-react-native/android')include ':jcore-react-native'project(':jcore-react-native').projectDir = new File(rootProject.projectDir, '../node_modules/jcore-react-native/android') 如下图所示 （3）在 AndroidManifest.xml 文件中添加以下内容： 文件路径：android\\app\\src\\main\\AndroidManifest.xml 1234&lt;meta-data android:name=&quot;JPUSH_CHANNEL&quot; android:value=&quot;${JPUSH_CHANNEL}&quot;/&gt;&lt;meta-data android:name=&quot;JPUSH_APPKEY&quot; android:value=&quot;${JPUSH_APPKEY}&quot; /&gt; 如下图所示 （4） 修改 MainApplication.java 文件 文件路径：android\\app\\src\\main\\java\\com\\myreactnativedemo\\MainApplication.java 进行如下修改： 1234567891011// 1.+ import cn.jiguang.plugins.push.JPushModule;// 2. @Override public void onCreate() { super.onCreate(); SoLoader.init(this, /* native exopackage */ false); // 调用此方法：点击通知让应用从后台切到前台 JPushModule.registerActivityLifecycle(this); } 在项目中使用 jpush-react-native直接使用官方的 App.js 例子 jpush-react-native/App.js at dev · jpush/jpush-react-native 稍作修改，添加如下内容： 123456&lt;!-- 给本机应用设置别名，其中 '190395486111268864' 是自己的因思云 userId --&gt;&lt;Button title=&quot;setAlias&quot; onPress={() =&gt; JPush.setAlias({sequence: 6, alias: '190395486111268864'}) }/&gt; 打包项目并安装（1）打包项目 1234# 打开 android 文件夹cd android# 打包 release 应用./gradlew assembleRelease 打包成功！ （2）将 APK 安装到真机上 注意：一定要打开手机的通知权限！ 安装到手机上时报运行异常错误 调试一下查看错误原因。 报错提示： 这个之前遇见过，是因为将 applicationId 设置为了 “com.xxxxxxx.xxxxxx”，先改回来看一看有没有其他的报错。 报错提示： TypeError: _jpushReactNative.default.addCustomMessagegListener is not a function. 找到原因：官方提供的 App.js 文件中 addCustomMessageListener 拼写错了，Message 后面多一个 g 将 applicationId 改回 “com.xxxxxxx.xxxxxx”，再次打包，并安装到手机上。结果可以正常使用。 （3）设置别名 注意：一定要打开手机的通知权限！ 点击 setAlias 按钮，给该 App 设置别名 验证极光推送是否集成成功在极光推送平台上模拟推送通知，查看手机是否能够接收到通知。 尝试模拟推送通知，但手机上未接收到推送通知。 原因：突然发现刚才打包的应用的 applicationId 为 com.myreactnativedemo，没有改过来，改回 com.xxxxxxx.xxxxxx 后 ，再重新打包，并安装到手机上。结果可以接收到通知！ 注意：一定要打开手机的通知权限！ 极光推送集成成功!!!","link":"/2021/12/25/React-Native-0-66-Demo-%E9%9B%86%E6%88%90%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%EF%BC%88Android%EF%BC%89/"},{"title":"git 一台设备多个 Git 账户管理","text":"目前我有3个 Git 账户，前一个是私人账户（Github 和 Gitee 共用），后一个是公司账户 1234github.com / gitee.com账户：xxxxxxxxxx 邮箱：xxxxxxxx@qq.comgit.code.tencent.com (腾讯工蜂)账户：xxxxxxxxxx 邮箱：xxxxxxxx@xxx.com 在自己的笔记本上办公时，既需要同步私人仓库的代码，又需要同步公司仓库的代码；在私人 git 账户和公司 git 账户之间切换非常麻烦，每次都需要重新生成 SSH key。若不想切换账户，就必须将用公司 git 账户生成的 SSH key 添加至私人仓库的 SSH keys 列表中，但我不想将二者混淆，于是参照下述博文进行了配置。 git 多个 SSH key 管理1.1 创建 SSH key 12345# 1. 创建公钥ssh-keygen -t rsa -C &quot;xxxxxxxx@xxx.com&quot;# 2. 将公钥重命名为 id_rsa_tencent/c/Users/admvli2016/.ssh/id_rsa_tencent# 3. 之后一直回车即可 同理另一个 SSH key 创建流程如下所示 12ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;/c/Users/admvli2016/.ssh/id_rsa_github&amp;&amp;gitee 1.2 配置 SSH 代理 12345678910# 1. 查询系统 SSH KEY 的代理ssh-add -l# 若已设置代理，需要删除ssh-add -D# 若提示 Could not open a connection to your authentication agent. 执行以下命令exec ssh-agent bash# 2. 添加刚才创建的 SSH KEY 的私钥ssh-add ~/.ssh/id_rsa_tencentssh-add ~/.ssh/id_rsa_github&amp;&amp;gitee 识别不了 &amp;&amp; 连接的字符，重新生成公钥 12ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;/c/Users/admvli2016/.ssh/id_rsa_github_gitee 重新添加 1ssh-add ~/.ssh/id_rsa_github_gitee 1.3 添加公钥 git 常用操作小结 - Admvli2016’s Blog 参照上述博文 1.4 配置文件 config 123456789101112131415161718192021222324# 1. 在 /.ssh 目录下创建 config 配置文件vim ~/.ssh/config# 2. config 文件内容如下# github 配置Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_github_gitee# gitee 配置Host gitee.com HostName gitee.com User git IdentityFile ~/.ssh/id_rsa_github_gitee # 腾讯工蜂配置Host git.code.tencent.com HostName git.code.tencent.com User git IdentityFile ~/.ssh/id_rsa_tencent # 3. 编辑保存 config，再次查看 SSH KEY 的代理ssh-add -l 发现到第3步后有问题 还是报错： The agent has no identities. 配置git链接到github遇到的问题_少年时。-CSDN博客 参照上述博文重新添加 1.5 验证 SSH key 1234# 输入以下命令，验证配置是否成功ssh -T github.comssh -T gitee.comssh -T git.code.tencent.com 但是运行 ssh -T git.code.tencent.com 时报错，如下所示 可能是由于腾讯工蜂不支持 SSH 登录这种方式 git 多个账户管理2.1 检查全局配置 1234567# 查看全局配置git config --global user.namegit config --global user.email# 为了后续避免麻烦，我们可以取消全局配置git config --global --unset user.namegit config --global --unset user.email 2.2 全局配置与局部配置 1234567# 1. cd进入到指定git仓库的根目录下，执行局部git配置命令cd D:\\Source\\ShenGuYun\\Code\\ins-appgit config user.namegit config user.email# 2. 若返回均为空，说明未进行过局部配置，分别配置github/gitee/腾讯工蜂的账户名和邮箱git config user.name &quot;xxxxxxxx&quot;git config user.email &quot;xxxxxxxx@qq.com&quot; 同理，其他 git 仓库按照上述步骤依次进行操作即可。已尝试，gitee/github/腾讯工蜂上都可成功拉取/推送 另外即使没有取消默认的全局git配置，在进行了局部配置后，后者的优先级也会更高。 1git config --list 查看当前仓库的具体配置信息，在当前仓库目录下查看的配置是全局配置+当前项目的局部配置，使用的时候会优先使用当前仓库的局部配置，如果没有，才会去读取全局配置。 2.3 hexo 部署时 git 提交报错问题 之前取消了 git 全局配置，只要将其恢复， hexo 就可以正常部署了。 参考博文： 一台电脑管理多个Git账户和SSH KEY 霖溦之境 同一客户端下使用多个 Git 账号 - 掘金","link":"/2021/12/23/git-%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87%E5%A4%9A%E4%B8%AA-Git-%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/"},{"title":"nvm 安装与使用","text":"nvm 安装（Windows）1.1 下载安装包 1.2 选择自定义安装目录，例如 D:\\Software\\nvm 1.3 设置 nodejs 的安装存储目录，例如 D:\\Software\\nvm\\nodejs 1.4 查看 nvm 是否安装成功 12# 查看 nvm 版本nvm version 1.5 配置 node 和 npm 的镜像地址 1234# 配置 node 镜像地址nvm node_mirror https://npm.taobao.org/mirrors/node/# 配置 npm 镜像地址nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 1.6 打开安装目录 D:\\Software\\nvm，新建一个文件夹 nodejs 1.7 设置环境变量 用户变量：将 NVM_SYMLINK 变量值改为 D:\\Software\\nvm\\nodejs 系统变量：将 NVM_SYMLINK 变量值改为 D:\\Software\\nvm\\nodejs 1.8 关闭 cmd 或 powershell，然后重新打开，这一步的目的是为了使环境变量生效 1.9 安装 node 版本 12345678910# 查看可安装的 node 版本列表nvm list available# 安装 node v14.17.3nvm install 14.17.3# 切换 node 版本nvm use 14.17.3# 查看 node 版本node -v# 查看 npm 版本npm -v 1.10 设置 npm 全局依赖在各 node 版本之间共享（安装全局依赖使用 npm i xxx -g） （1）用 npm root -g 命令，可查看 npm 全局依赖默认的存储位置 默认的 npm 全局依赖安装目录：C:\\Users\\admvli2016\\AppData\\Roaming\\npm 默认的 npm 全局依赖缓存目录：C:\\Users\\admvli2016\\AppData\\Roaming\\node_cache （2）修改 npm 全局依赖安装目录、npm 全局依赖缓存目录 在 D:\\Software\\nvm 文件夹下创建 node_global 和 node_cache 文件夹 1234# 修改 npm 全局依赖安装目录：npm config set prefix &quot;D:\\Software\\nvm\\node_global&quot;# 修改 npm 全局依赖缓存目录：npm config set cache &quot;D:\\Software\\nvm\\node_cache&quot; 这样做的目的主要为了避免在不同 node 版本下都安装一遍需要的 npm 全局依赖 若需要安装的 npm 全局依赖之间存在版本冲突等不兼容问题（如一个项目依赖 ionic/cli@3.9.2 ，另一个项目依赖 ionic/cli@6.16.3），则不建议采取上述策略。可按步骤（3）操作 （3）修改 npm 全局依赖安装目录、npm 全局依赖缓存目录（可选） 在 D:\\Software\\nvm\\nodejs 文件夹下创建 node_global 和 node_cache 文件夹 1234# 修改 npm 全局依赖安装目录：npm config set prefix &quot;D:\\Software\\nvm\\nodejs\\node_global&quot;# 修改 npm 全局依赖缓存目录：npm config set cache &quot;D:\\Software\\nvm\\nodejs\\node_cache&quot; 这样做的缺点是对于常用的 npm 全局依赖需要在所有需要的 node 版本下都安装一遍。 1.11 设置系统变量 （1）新增环境变量 NODE_PATH D:\\Software\\nvm\\node_global\\node_modules （2）在 PATH 变量上添加 D:\\Software\\nvm\\node_global 若上一步进行了操作（3），这一步也需要相应地更改文件夹路径。 新增环境变量 NODE_PATH D:\\Software\\nvm\\nodejs\\node_global\\node_modules 在 PATH 变量上添加 D:\\Software\\nvm\\nodejs\\node_global 1.12 设置淘宝镜像 12# 设置淘宝镜像npm config set registry=http://registry.npm.taobao.org 1.13 nvm 常用命令 1234567891011121314151617181920# 查看当前系统是 32bit 还是 64bitnvm arch # 安装 xxx 版本的 node（32bit / 64bit）nvm install xxx [arch] # 查看可安装的 node 版本列表nvm list available # 查看已安装的 node 版本列表nvm list / nvm list installed # 配置 node 镜像地址nvm node_mirror [url] # 配置 npm 镜像地址nvm npm_mirror [url] # 卸载 xxx 版本的 nodenvm uninstall xxx # 切换 node 版本nvm use [version] [arch] # 查看 nvm 版本nvm version # 帮助nvm help 参考博文： (30条消息) nodejs环境变量配置及使用n及nvm进行版本切换_ruanhongbiao的专栏-CSDN博客_nvm安装的node环境变量 nvm 安装（macOS）2.1 安装 Homebrew The Missing Package Manager for macOS (or Linux) — Homebrew 12# 安装 Homebrew/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 安装失败 MacOs M1安装Homebrew 在国内最简单方法_YD-10-NG的博客-CSDN博客 参照上述博文 12# 主机是 intel 芯片/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 安装成功 2.2 安装 nvm 12# 安装 nvmbrew install nvm 安装成功 2.3 配置可在 shell 中使用 nvm 命令 12345678910# 查看是否存在 ~/.nvm 文件夹cd ~/.nvm # 创建 ~/.nvm 文件夹mkdir ~/.nvm# 查看是否存在 ~/.profile 文件cd ~/.profile# 返回根目录cd ~# 创建 .profile 文件touch .profile 打开并在 .profile 文件中添加如下信息 123export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;/usr/local/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/usr/local/opt/nvm/nvm.sh&quot; # This loads nvm [ -s &quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot; # This loads nvm bash_completion MAC：通过NVM安装指定版本的node - 简书 参照上述博文，重新 source 1source .profile 2.4 使用 nvm 安装不同版本 node 12345678# 查看远程所有可用的 node 版本nvm ls-remote# 下载想要安装的版本nvm install xxx # nvm install v8.11.3# 使用指定版本的 nodenvm use xxx # nvm use v8.11.3# 每次启动终端都使用该版本的 nodenvm alias default xxx # nvm alias default v8.11.3 2.5 查看版本信息 1234# 查看 node 版本node -v# 查看 npm 版本npm -v 还可以配置在不同 node 版本下全局安装的依赖始终可用，参照下述博文： (12条消息) mac nodejs安装_weixin_30791095的博客-CSDN博客","link":"/2021/12/08/nvm-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"React Native 0.66 Demo 搭建全过程（iOS）","text":"开发环境搭建（iOS）本文 Demo 是在 iMac 上完成搭建的。 搭建开发环境 · React Native 中文网 参照上述博文，需要安装的软件 1234Node 要求 v12 以上版本 Watchman stable 2021.10.18.00 (bottled)Xcode Version 13.0 (13A233)CocoaPods stable 1.11.2 (bottled) 怎么查看 mac 是否安装了cocoapods_百度知道 12# 查看 CocoaPods 的版本号pod --version Mac 操作系统环境现状 1234Node 已安装 v8.11.3Watchman 未安装 Xcode 已安装 Version 13.0 (13A233)CocoaPods 未安装 安装 Homebrew The Missing Package Manager for macOS (or Linux) — Homebrew 参照上述博文 12# 安装 Homebrew/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 安装失败。 MacOs M1安装Homebrew 在国内最简单方法_YD-10-NG的博客-CSDN博客 参照上述博文，重新安装。 12# 主机是 intel 芯片/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 安装成功。 安装 watchman1brew install watchman 安装失败，报错： 按照提示，尝试安装 python@3.9 1brew install --build-from-source python@3.9 安装完成，再次运行 brew install watchman 安装成功！ brew info watchman 查看 Homebrew 安装的 watchman 详细信息。 12# 验证是否安装成功watchman --help 安装 CocoaPods1brew install cocoapods 安装成功！ brew info cocoapods 查看 Homebrew 安装的 cocoapods 详细信息 安装 Node可参照下面的博文安装 nvm，通过 nvm 来安装 node 、管理 node 版本 nvm 安装与使用 - Admvli2016’s Blog 安装 Yarn12# 安装 Yarnnpm install -g yarn 创建 React Native 项目1234# 进入文稿目录cd ~/Documents# 创建新项目npx react-native init MyReactNativeDemo --template react-native-template-typescript 创建 React Native 项目失败，报错: Unexpected token { 估计是因为 node 的版本问题，切换到 v12.22.0。 发现确实是 node 的版本问题。 卡在 CocoaPods 安装依赖，需要 VPN CocoaPods 安装依赖完成 运行 React Native 项目运行项目（模拟器）1234# 进入项目目录cd MyReactNativeDemo# 运行 yarn iosyarn ios 可以指定特定的模拟器运行 1npx react-native run-ios --simulator &quot;iPhone 4s&quot; 可以在终端中运行 xcrun simctl list devices 来查看具体可用的设备名称。 很快可以看到 iOS 模拟器自动启动并运行项目。 在正常编译完成后，开发期间要保持 Metro 命令行窗口运行而不要关闭。以后需要再次运行项目时， 如果没有修改过 ios 目录中的任何文件，则只需单独启动 yarn start 命令。如果对 ios 目录中任何 文件有修改，则需要再次运行 yarn ios 命令完成原生部分的编译。 初次运行，启动时间较长，请耐心等待。 运行项目（真机）在设备上运行 · React Native 中文网 参照上述博文 （1）通过 USB 数据线连接设备 （2）用 Xcode 打开 MyReactNativeDemo.xcworkspace 文件 （3）如果这是第一次在 iOS 设备上运行 APP，需要注册开发设备。从 Xcode 菜单栏打开 Product 菜单，然后前 往 Destination。从列表中查找并选择设备，将其注册为开发设备。 （4）配置代码签名 如图所示，点击 MyReactNativeDemo 编辑 General 目录，将 Bundle Identifier 改为 com.xxxxxxx.xxxxxx，并进行以下更改。 （5）编译并运行应用 操作路径：Product &gt; Run App 将会被自动安装到真机上。 这一步的报错信息： 12345678Unable to install &quot;因思云&quot;Domain: com.apple.dt.MobileDeviceErrorDomainCode: -402620394User Info: { IDERunOperationFailingWorker = IDEInstalliPhoneLauncher;}--The executable was signed with invalid entitlements. iOS开发-真机调试遇到“The executable was signed with invalid entitlements.” zhangzr’s blog 参照上述博文，将 Run 的模式 (Scheme) 由 Release 改为 Debug，还是报错了。 123456789Could not launch “因思云”Domain: IDEDebugSessionErrorDomainCode: 3Failure Reason: failed to get the task for process 403User Info: { DVTRadarComponentKey = 855031; IDERunOperationFailingWorker = DBGLLDBLauncher; RawUnderlyingErrorMessage = &quot;failed to get the task for process 403&quot;;} 可能是自己点击手机 APP 点早了，重试一次。 123456789Could not launch “因思云”Domain: IDEDebugSessionErrorDomainCode: 3Failure Reason: failed to get the task for process 282User Info: { DVTRadarComponentKey = 855031; IDERunOperationFailingWorker = DBGLLDBLauncher; RawUnderlyingErrorMessage = &quot;failed to get the task for process 282&quot;;} 还是不行。 Xcode7.3真机调试 报错:process launch failed: failed to get the task for process XXXX - 简书 Xcode failed to get the task for process XXX - 简书 参照上述博文，真机调试时的证书必须是开发证书，所以还需要去配置开发证书。 极光推送 - iOS 证书设置指南 - 极光文档 参照上述文档，只需要重新生成一个 Developer 环境的 Provisioning Profile 文件即可。 生成之后，再在 Xcode 上面进行配置。 再次尝试真机联调（开发环境），安装到手机上成功！ 注意记录一下 Developer 的钥匙串访问密码 ：xx1234 （可能需要输入几次） 修改项目代码（1）使用 VS Code 打开 App.js 并进行修改 （2）在 VS Code 中按 Ctrl + S 保存，就可以看到最新的修改结果。 修改结果： 调试 React Native 项目在 iOS 设备上运行应用参照 3.2 中的步骤即可。 从设备上访问开发服务器 注意：调试时手机和电脑都必须在同一WIFI环境下，电脑不要连接网线 ! React Native iOS 真机调试 - 简书 参照上述博文，在 Mac 上查看本机 IP 地址 12# 在 Mac 上查看本机 IP 地址ifconfig 断开 iMac 网线，然后连接 wifi 苹果电脑如何连接网络wifi-百度经验 发现在打开的 Packager 页面中按 d 唤出开发菜单，手机并没有反应；但是摇一摇调试设备却可以打开开发菜单。 点击 Debug with Chrome 时，出现了如下的报错： 猜测可能是 Xcode 缓存的原因，因为我点击 Run 的时候还没有拔网线。 再次尝试，运行项目并安装到手机上，打开开发菜单，点击 Debug with Chrome ，结果成功了。 它将会自动在 Chrome 浏览器中新开一个标签页，内容如下所示： 如此同时，手机上的 App 将会重新加载页面并刷新。 React Native 项目打包上架上架应用的过程和其它原生的 iOS 应用一样。 用 Xcode 打开项目 ios 文件夹下的 MyReactNativeDemo.xcworkspace 文件。 如图所示点击 MyReactNativeDemo 编辑 General 目录将 Bundle Identifier 改为 com.xxxxxxx.xxxxxx 并进行以下更改 编辑 Signing &amp; Capabilities 目录Team 选择 Shenyang Blower Works Group M &amp;C Tech. Co, Ltd. 并进行以下更改 添加 Background Modes 添加 Push Notifications 编辑 Info 目录将 Localization native development region 值改为 China 将 App Transport Security Settings &gt; Exception Domains 下的 localhost 移除 编辑 Build Settings 目录将 ProductName 值改为 因思云 配置 release scheme配置 App 使用 Release scheme 编译，前往 Product &gt; Scheme &gt; Edit Scheme。选择侧边栏的 Run 标签，然后设置下拉的 Build Configuration 为 Release。 打包应用从菜单栏选择 Product &gt; Build 编译发布 App 另外还可以使用 React Native CLI 发布，执行以下命令 1npx react-native run-ios --configuration Release 内测分发使用 蒲公英 进行内测分发 蒲公英-免费的苹果ios应用app内测分发托管|android安卓app内测分发托管 如果之前没有创建过应用，需要自己手动去创建。 内测分发步骤如下： （1）找到 项目名称.xcodeproj 或者 项目名称.xcworkspace 文件，使用 Xcode 打开 （2）选择 Archive 确保此时 Signing &amp; Capabilities &gt; Signing（Release）&gt; Provisioning Profile 选择的是 Ad Hoc （3）成功后点击 Distribute App 按钮 （4）选择 Ad Hoc （5）直接点击 Next （6）项目名称.app 处选择 Ad Hoc （7）最后选择 Export ，将文件导出到桌面 （8）登录蒲公英网站 蒲公英-免费的苹果ios应用app内测分发托管|android安卓app内测分发托管 （9）进入应用管理，选择 发布/更新应用，点击更新 （10）点击立刻上传 （11）选择之前导出的 ipa 文件 选择之前导出的文件夹，导出来的文件夹都是有时间戳的，选择最近时间的文件夹即可。 然后选择该文件夹中的 项目名称.ipa 文件。 等待上传完成后，再进行下一步。 （12）点击 发布应用 （13）发布完应用之后，页面会自动跳转回 发布/更新应用 页面 点击版本列表中最上面的一项（刚才上传的），手机扫描二维码即可下载安装对应版本 APP （14）跳转到当前页面 手机扫描二维码，输入密码 sg1234，即可下载安装对应版本 APP 安装后 APP 运行截图","link":"/2021/12/25/React-Native-0-66-Demo-%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%88iOS%EF%BC%89/"},{"title":"Ionic5.x+Capacitor+Vue3.x 集成 Code Push（Android）","text":"App Center 注册用户App Center 访问 App Center，注册一个账户 使用 GitHub 创建，点击 Authorize App Center 输入密码，然后选择用户名（Choose username） 进入之后的界面 本地 Code Push 环境配置参考博文 https://docs.microsoft.com/en-us/appcenter/distribution/codepush/ https://docs.microsoft.com/en-us/appcenter/distribution/codepush/cli React Native]使用App Center CLI发布CodePush更新–iOS简易版_weixin_33873846的博客-CSDN博客 按照入门说明进行如下配置 2.1 安装 appcenter-cli 1234# 安装 appcenter-clinpm install -g appcenter-cli# 登录 appcenterappcenter login appcenter-cli 的 login 命令会打开浏览器，要求用户在浏览器上进行认证，认证完成后会生成一个 access key ，粘贴这个 key 到命令行，完成认证 2.2 管理 App 1234567891011121314151617181920212223242526272829303132333435363738# 使用 appcenter-cli 在 appcenter 中创建两个 app 应用appcenter apps create -d IonicDemo-Android -o Android -p Cordovaappcenter apps create -d IonicDemo-IOS -o iOS -p Cordova# 查看 appcenter 中创建的应用appcenter apps list# 重命名 appappcenter apps update -n &lt;newName&gt; -a &lt;ownerName&gt;/&lt;appName&gt;# 删除 appappcenter apps delete -a &lt;ownerName&gt;/&lt;appName&gt;# 设置当前操作应用appcenter apps set-current 3148441341-qq.com/IonicDemo-Android# 这样可以缩短命令，如下：# 缩短后appcenter codepush deployment list --displayKeys# 原命令appcenter codepush deployment list --displayKeys -a &lt;ownerName&gt;/&lt;appName&gt; # 查看当前操作的应用appcenter apps get-current# 手动创建两个部署（ Staging 和 Production ）# 缩短后appcenter codepush deployment add Staging appcenter codepush deployment add Production# 原命令appcenter codepush deployment add -a &lt;ownerName&gt;/&lt;appName&gt; Stagingappcenter codepush deployment add -a &lt;ownerName&gt;/&lt;appName&gt; Production# 访问两个部署的部署密钥# 缩短后appcenter codepush deployment list --displayKeys# 原命令appcenter codepush deployment list --displayKeys -a &lt;ownerName&gt;/&lt;appName&gt; 当前 App 应用的两个部署的部署密钥 在项目中集成 Code Push3.1 安装 capacitor-codepush 123456# 安装 capacitor 插件npm i @capacitor-community/http @capacitor/deivce @capacitor/dialog @capacitor/filesystem# 安装 capacitor-codepush npm i https://github.com/mapiacompany/capacitor-codepush # 同步到 android / ios platformionic cap sync 3.2 在 capacitor.config.json 中配置 deployment key capacitor.config.json 配置模板 1234567891011// capacitor.config.json&quot;Plugins&quot;: { ... (other plugins) &quot;CodePush&quot;: { &quot;IOS_DEPLOY_KEY&quot;: &quot;IOS_DEPLOYMENT_KEY&quot;, &quot;IOS_PUBLIC_KEY&quot;: &quot;APP_SECRET_KEY&quot;, &quot;ANDROID_DEPLOY_KEY&quot;: &quot;ANDROID_DEPLOYMENT_KEY&quot;, &quot;ANDROID_PUBLIC_KEY&quot;: &quot;APP_SECRET_KEY&quot;, &quot;SERVER_URL&quot;: &quot;https://codepush.appcenter.ms/&quot; }} 如果只需要配置 Android 或者 iOS 其中一个平台的话，另一个平台的配置不需要写 如果 Release 时不需要使用公私钥认证的话，PUBLIC_KEY 的配置也不需要写 配置之后的 capacitor.config.json 12345678910111213// capacitor.config.json{ &quot;appId&quot;: &quot;com.ionicframework.xxxxxx&quot;, &quot;appName&quot;: &quot;因思工业服务&quot;, &quot;webDir&quot;: &quot;dist&quot;, &quot;bundledWebRuntime&quot;: false , &quot;Plugins&quot;: { &quot;CodePush&quot;: { &quot;ANDROID_DEPLOY_KEY&quot;: &quot;X1vN32baDusvL1nVB15I9erm_9NRrBc_-YvwA&quot;, &quot;SERVER_URL&quot;: &quot;https://codepush.appcenter.ms/&quot; } }} 3.3 配置 CSP ，确保 App 能够访问到 Code Push 的服务器 在 index.html 中，添加 Content-Security-Policy 的 meta 标签 12&lt;!--index.html--&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src https://codepush.appcenter.ms 'self' data: gap: https://ssl.gstatic.com 'unsafe-eval'; style-src 'self' 'unsafe-inline'; media-src *&quot; /&gt; 3.4 添加示例代码 12345678910111213141516171819202122232425262728293031&lt;!-- App.vue --&gt;&lt;template&gt; &lt;ion-app&gt; &lt;ion-router-outlet /&gt; &lt;/ion-app&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { IonApp, IonRouterOutlet } from '@ionic/vue';import { defineComponent, onMounted } from 'vue';import Jpush from &quot;@/utils/jpush&quot;;import { SplashScreen } from '@capacitor/splash-screen';import { codePush } from'capacitor-codepush';export default defineComponent({ name: 'App', components: { IonApp, IonRouterOutlet }, setup() { onMounted(() =&gt; { // 由于是cordova插件，需要在deviceready回调后才能使用，用过Cordova的都懂 document.addEventListener('deviceready', () =&gt; { new Jpush().setAlias('190395486111268864'); codePush.sync({ updateDialog: true }); // 热更新检查 }) setTimeout(() =&gt; SplashScreen.hide(), 2000); }) }});&lt;/script&gt; 发布热更新4.1 打包生成的网页资源存放在 dist 目录下 12345678910111213// capacitor.config.json{ &quot;appId&quot;: &quot;com.ionicframework.sipapp202440&quot;, &quot;appName&quot;: &quot;因思工业服务&quot;, &quot;webDir&quot;: &quot;dist&quot;, // 打包生成的web资源存放路径 &quot;bundledWebRuntime&quot;: false , &quot;Plugins&quot;: { &quot;CodePush&quot;: { &quot;ANDROID_DEPLOY_KEY&quot;: &quot;X1vN32baDusvL1nVB15I9erm_9NRrBc_-YvwA&quot;, &quot;SERVER_URL&quot;: &quot;https://codepush.appcenter.ms/&quot; } }} 4.2 通过 appcenter-cli 发布更新 1234567891011121314151617# 发布更新到 Production 环境，并指定受众版本不小于 1.0# 缩短后appcenter codepush release -c dist/ --target-binary-version &quot;~1.0&quot; -d Production# 原命令appcenter codepush release -a &lt;ownerName&gt;/&lt;appName&gt; -c dist/ --target-binary-version &quot;~1.0&quot; -d Production# 详解appcenter codepush release -a &lt;ownerName&gt;/&lt;appName&gt; -c &lt;updateContentsPath&gt; -t &lt;targetBinaryVersion&gt; -d &lt;deploymentName&gt;# [-с|--update-contents-path &lt;updateContentsPath&gt;] # 指定更新内容的路径# [-t|--target-binary-version &lt;version&gt;] # 指定此次 release 的受众版本，不在该版本范围内的用户将不能下载此次更新# [-d|--deployment-name &lt;deploymentName&gt;] # 指定是 Staging 或者 Production 4.3 模拟热更新 （1） 手机上要安装用于 Debug 或 Release 的 Apk、同时要进行一次热更新，将此时的页面内容上传至热更新服务器，作为初始内容 （2） 修改页面内容，然后进行热更新，但在热更新之前，需要运行如下命令，再上传热更新内容 12ionic buildionic cap sync # 保证写入热更新内容 否则发布热更新时会出现如下报错 12Error: The uploaded package was not released because it is identical to the contents of the specified deployment's current release.# 错误：上载的包未发布，因为它与指定部署的当前版本的内容相同。 4.4 第一次模拟热更新 手机并没有出现热更新提示 Android Studio Debug 报错信息：”Could not get preference: ANDROID_DEPLOY_KEY” 12345678910111213D/Capacitor: Sending plugin error: {&quot;save&quot;:false,&quot;callbackId&quot;:&quot;22681177&quot;,&quot;pluginId&quot;:&quot;CodePush&quot;,&quot;methodName&quot;:&quot;getDeploymentKey&quot;,&quot;success&quot;:false,&quot;error&quot;:{&quot;message&quot;:&quot;Could not get preference: ANDROID_DEPLOY_KEY&quot;}}D/Capacitor: Handling local request: http://localhost/js/chunk-2d0c9758.62f099a9.jsD/Capacitor: Handling local request: http://localhost/js/chunk-69eb8776.8f434896.jsI/Capacitor/Console: File: http://localhost/ - Line 213 - Msg: undefinedE/Capacitor/Console: File: http://localhost/js/chunk-vendors.37e09625.js - Line 1 - Msg: [CodePush] Deployment key not found.. StackTrace: Error: Deployment key not found. at Function.&lt;anonymous&gt; (http://localhost/js/chunk-vendors.37e09625.js:1:9481) at Generator.throw (&lt;anonymous&gt;) at s (http://localhost/js/chunk-vendors.37e09625.js:1:8490)E/Capacitor/Console: File: http://localhost/js/chunk-vendors.37e09625.js - Line 1 - Msg: [CodePush] An error occurred during sync. Deployment key not found.. StackTrace: Error: Deployment key not found. at Function.&lt;anonymous&gt; (http://localhost/js/chunk-vendors.37e09625.js:1:9481) at Generator.throw (&lt;anonymous&gt;) at s (http://localhost/js/chunk-vendors.37e09625.js:1:8490)E/Capacitor/Console: File: http://localhost/js/chunk-vendors.37e09625.js - Line 1 - Msg: Uncaught (in promise) Error: Deployment key not found. 从报错信息上来看，是因为没有读取到 Deployment key 更改示例代码，syncOption 中添加 deploymentKey ，重新打包 12345// App.vuecodePush.sync({ updateDialog: true, deploymentKey:'X1vN32baDusvL1nVB15I9erm_9NRrBc_-YvwA' }); 4.5 第二次模拟热更新 手机上有热更新提示，但是更新未安装成功 Android Studio Debug 报错信息 “Could not get the package start page” 1234567891011121314D/Capacitor: Sending plugin error: {&quot;save&quot;:false,&quot;callbackId&quot;:&quot;2315552&quot;,&quot;pluginId&quot;:&quot;CodePush&quot;,&quot;methodName&quot;:&quot;preInstall&quot;,&quot;success&quot;:false,&quot;error&quot;:{&quot;message&quot;:&quot;Could not get the package start page&quot;}}V/Capacitor/Plugin: To native (Capacitor plugin): callbackId: 2315553, pluginId: CodePush, methodName: getServerURLV/Capacitor: callback: 2315553, pluginId: CodePush, methodName: getServerURL, methodData: {}E/Capacitor/Console: File: http://localhost/js/chunk-vendors.37e09625.js - Line 1 - Msg: [CodePush] Preinstall failure. Could not get the package start page. StackTrace: Error: Could not get the package start page at Object.cap.fromNative.result [as fromNative] (http://localhost/:426:32) at &lt;anonymous&gt;:1:18D/Capacitor: Sending plugin error: {&quot;save&quot;:false,&quot;callbackId&quot;:&quot;2315553&quot;,&quot;pluginId&quot;:&quot;CodePush&quot;,&quot;methodName&quot;:&quot;getServerURL&quot;,&quot;success&quot;:false,&quot;error&quot;:{&quot;message&quot;:&quot;Could not get preference: SERVER_URL&quot;}}E/Capacitor/Console: File: http://localhost/js/chunk-vendors.37e09625.js - Line 1 - Msg: [CodePush] An error has occured while installing the package. Could not get the package start page. StackTrace: Error: An error has occured while installing the package. Could not get the package start page at c (http://localhost/js/chunk-vendors.37e09625.js:1:17470)V/Capacitor/Plugin: To native (Capacitor plugin): callbackId: 2315554, pluginId: CodePush, methodName: getAppVersionV/Capacitor: callback: 2315554, pluginId: CodePush, methodName: getAppVersion, methodData: {}E/Capacitor/Console: File: http://localhost/js/chunk-vendors.37e09625.js - Line 1 - Msg: [CodePush] An error occurred during sync. An error has occured while installing the package. Could not get the package start page. StackTrace: Error: An error has occured while installing the package. Could not get the package start page at c (http://localhost/js/chunk-vendors.37e09625.js:1:17470)E/Capacitor/Console: File: http://localhost/js/chunk-vendors.37e09625.js - Line 1 - Msg: Uncaught (in promise) Error: An error has occured while installing the package. Could not get the package start page https://github.com/mapiacompany/capacitor-codepush#api-reference 从 capacitor-codepush 的 API 文档中查阅到： 提供给 -c 标志的路径可能因平台或框架而异，Ionic 项目的路径如下 Android : ./android/app/src/main/assets/public/ iOS : ./ios/App/App/public/ 所以是自己之前的热更新命令错了，更改发布命令 1appcenter codepush release -c android/app/src/main/assets/public/ --target-binary-version &quot;~1.0&quot; -d Production 4.6 第三次模拟热更新 手机上有热更新提示，但是更新内容未安装成功（后面发现其实并不是更新内容未安装成功，而是更新内容未立即安装，关闭之后再重新打开才会安装更新内容） Android Studio Debug 报错信息 “File does not exist”/data/user/0/com.ionicframework.sipapp202440/files/codepush/currentPackage.json (No such file or directory) https://github.com/mapiacompany/capacitor-codepush/issues/21 此报错不影响功能正常使用，参照上述博文，该 BUG 已被修复，但错误日志未进行删除 12345678910111213141516171819/Capacitor: Sending plugin error: {&quot;save&quot;:false,&quot;callbackId&quot;:&quot;83886644&quot;,&quot;pluginId&quot;:&quot;Filesystem&quot;,&quot;methodName&quot;:&quot;stat&quot;,&quot;success&quot;:false,&quot;error&quot;:{&quot;message&quot;:&quot;File does not exist&quot;}}V/Capacitor/Plugin: To native (Capacitor plugin): callbackId: 83886645, pluginId: Filesystem, methodName: readFileV/Capacitor: callback: 83886645, pluginId: Filesystem, methodName: readFile, methodData: {&quot;directory&quot;:&quot;DATA&quot;,&quot;path&quot;:&quot;codepush\\/currentPackage.json&quot;,&quot;encoding&quot;:&quot;utf8&quot;}E/Capacitor/Plugin: File does not exist java.io.FileNotFoundException: /data/user/0/com.ionicframework.sipapp202440/files/codepush/currentPackage.json (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:231) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:165) at com.capacitorjs.plugins.filesystem.Filesystem.getInputStream(Filesystem.java:152) at com.capacitorjs.plugins.filesystem.Filesystem.readFile(Filesystem.java:24) at com.capacitorjs.plugins.filesystem.FilesystemPlugin.readFile(FilesystemPlugin.java:62) at java.lang.reflect.Method.invoke(Native Method) at com.getcapacitor.PluginHandle.invoke(PluginHandle.java:121) at com.getcapacitor.Bridge.lambda$callPluginMethod$0$Bridge(Bridge.java:584) at com.getcapacitor.-$$Lambda$Bridge$25SFHybyAQk7zS27hTVXh2p8tmw.run(Unknown Source:8) at android.os.Handler.handleCallback(Handler.java:873) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:224) at android.os.HandlerThread.run(HandlerThread.java:65) https://github.com/mapiacompany/capacitor-codepush#syncoptions installMode (InstallMode) - Specifies when you would like to install optional updates (i.e. those that aren’t marked as mandatory). Defaults to InstallMode.ON_NEXT_RESTART. Refer to the InstallMode enum reference for a description of the available options and what they do. 更改 syncOptions，让用户点击 Install 之后立即更新，参照上述博文，installMode 默认值是 InstallMode.ON_NEXT_RESTART（下次重启之后再更新），将其改为 InstallMode.IMMEDIATE 即可 1234567891011121314151617// 更改后的 App.vueimport { codePush, InstallMode } from'capacitor-codepush';setup() { onMounted(() =&gt; { // 由于是cordova插件，需要在deviceready回调后才能使用，用过Cordova的都懂 document.addEventListener('deviceready', () =&gt; { new Jpush().setAlias('190395486111268864'); codePush.sync({ updateDialog: true, deploymentKey: 'X1vN32baDusvL1nVB15I9erm_9NRrBc_-YvwA', installMode: InstallMode.IMMEDIATE // 注意这里 }); }) setTimeout(() =&gt; SplashScreen.hide(), 2000); })} 4.7 第四次模拟热更新 手机上出现热更新提示，并且点击 install 之后立即热更新 之前的页面 热更新提示 热更新之后 Code Push 集成成功 !!!","link":"/2021/12/12/Ionic5-x-Capacitor-Vue3-x-%E9%9B%86%E6%88%90-Code-Push%EF%BC%88Android%EF%BC%89/"},{"title":"git 常用操作小结","text":"git 配置密钥 SSH Key1.1 首先检查一下用户名和邮箱是否配置 12# 查看全局的 git 配置git config --global --list 若未进行配置，则执行下列命令进行配置 12git config --global user.name &quot;admvli2016&quot;git config --global user.email &quot;3148441341@qq.com&quot; 1.2 然后执行以下命令生成密钥 SSH Key 1ssh-keygen -t rsa -C &quot;3148441341@qq.com&quot; 执行命令后需要进行3次或4次确认： i，确认秘钥的保存路径（如果不需要改路径则直接回车） ii，如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖） iii，创建密码（如果不需要密码则直接回车） iv，确认密码 直接敲3~4次回车即可 生成的 id_rsa 和 id_rsa.pub 文件默认的保存路径是： C:\\Users\\admvli2016.ssh 1.3 打开 id_rsa.pub 文件，将其内容复制 Gitee/GitLab/GitHub/腾讯工蜂 当中 可通过下列命令查看 id_rsa.pub 文件内容 12# 查看 id_rsa.pub 文件内容cat ~/.ssh/id_rsa.pub GitHub 中配置 SSH Gitee 中配置 SSH GitLab 中配置 SSH 腾讯工蜂中配置 SSH 参考博文： git ssh key配置 - 讨厌走开啦 - CSDN博客 利用Git生成本机SSH Key并添加到GitHub中 - 境由心生 - CSDN博客 (1条消息)github上传项目的时候报出git@github.com: Permission denied (publickey). fatal: Could not read from remote repo_weixin_44394753的博客-CSDN博客 git 查看 &amp; 设置用户名、用户邮箱2.1 git 查看当前用户名、用户邮箱 1234# 查看当前用户名git config user.name# 查看当前邮箱地址git config user.email 2.2 git 设置用户名、用户邮箱 1234567# 全局级配置，如果没有仓库级别的特殊配置，默认读取这个配置git config --global user.name &quot;name&quot;git config --global user.email &quot;email&quot;# 仓库级配置，一般一个项目配置一次git config user.name &quot;name&quot;git config user.email &quot;email&quot; 参考博文： GIT 查看/修改用户名和邮箱地址 - 程序园 git 创建本地仓库，与远程仓库关联123456789101112131415161718192021222324252627# 1，初始化本地仓库git init# 2，在 gitee/gitlab/github 上新建仓库# 新建的远程仓库地址： git@gitee.com:admvli2016/git-test.git# 查看本地关联的远程仓库地址git remote -v# 3，若本地已有关联的远程仓库，则会报错：'fatal:remote origin already exists'# 移除已有的远程仓库地址，再添加git remote remove origin# 4，添加新建的远程仓库地址git remote add origin git@gitee.com:admvli2016/git-test.git# 5，初次提交# 添加文件git add .# commit 提交git commit -m &quot;备注&quot;# 将本地分支 master 内容推送到远程仓库去# 第一次推送 master 分支时，加上了 –u 参数# 此时，git 不但会把本地的 master 分支内容推送到远程新的 master 分支上，还会把本地的 master 分支与远程的 master 分支关联起来git push -u origin master 或者 123# 1，在 gitee/gitlab/github 上新建仓库时选择初始化仓库# 2，然后使用 git clone &quot;xxx(刚才新建的远程仓库地址)&quot;，如下所示，也可将本地仓库与远程仓库关联起来git clone git@gitee.com:admvli2016/git-test.git 参考博文： git基础知识（一）之把本地仓库推送到github - 简书 使用git将本地项目推送到远程仓库github - 简书 将本地文件夹添加到Git仓库 - 坚守梦想 - 博客园 (1条消息)Git将本地文件夹添加到远程仓库_StarFishing-CSDN博客 git将本地文件上传到远程github仓库中丶Java教程网-IT开发者们的技术天堂 Git关联远程仓库 - 冬音 - 博客园 git报错：’fatal:remote origin already exists’怎么处理？附上git常用操作以及说明。 - leaf+ - 博客园 (5条消息) git仓库更换远程地址_IT水很深，路还很长-CSDN博客 git remote 命令 菜鸟教程 git 创建本地分支，推送至远程仓库12345# 1，本地新建分支# git branch xxx &amp;&amp; git checkout xxxgit checkout -b xxx# 2，将本地分支推送至远程仓库git push -u origin xxx git clone 拉下来的远程仓库代码一般都处于主分支上，如何切换至其他分支123456789101112# 1, 拉取远程仓库代码git clone git@git.code.tencent.com:sgc-ins-os/ui-app.git# 2, 创建并切换到 sg8k 分支# git branch sg8k &amp;&amp; git checkout sg8kgit checkout -b sg8k# 3, 将远程 sg8k 分支设为本地 sg8k 分支的上游分支git branch --set-upstream-to=origin/sg8k sg8k# 4, 拉取代码git pull 参考博文: (7条消息) 如何拉取 GitLab 上指定分支的内容？（附常用 git 命令）_Bule_daze的博客-CSDN博客_git怎么pull分支上的内容 git 下载远程仓库指定分支的代码12# 下载远程仓库 dev 分支上的代码git clone -b dev git@gitee.com:admvli2016/git-test.git 参考博文： 通过git命令行从github上下载指定branch的项目源码 - zhang168w520的博客 - CSDN博客 git 常规提交流程 &amp; 注释规范7.1 git 常规提交流程 1234567891011# 1，添加修改git add . || git add *# 2，commit 提交git commit -m &quot;备注&quot; || git commit -am &quot;备注&quot;# 3，拉取其他开发人员的更新内容git pull# 4，推送到远程分支git push 7.2 git 注释规范 注释开头 含义 feat 新功能的开发 fix 测试提的 bug 修复；开发过程中已开发功能发现的问题的修复（对测试提的 bug 需在注释末尾写明 Bug ID） docs 文档类修改 style 格式化、分号增删等修改，代码没有变动 refactor 代码重构：同样的功能点，只是逻辑上重构了该功能的编码实现 chore 依赖包升级，代码迁移、初始化、覆盖等，业务代码没变动 备注：1、举例，提交时注释 git commit -m “feat: 轨迹图找点功能” git commit -m “fix: 修复轨迹图XX问题” git stash 暂存修改123456789101112131415161718192021222324252627282930# 添加文件git add . || git add *# 将当前所有修改内容(未提交的)暂存，此时代码回到上一次的提交git stash# 列出所有暂存项git stash list# 删除队列中某一暂存项git stash drop stash@{0} # 删除最近的暂存项git stash drop stash@{1} # 删除第二近的暂存项git stash drop stash@{2} # 删除第三近的暂存项# 依此类推# 清除所有暂存项git stash clear# 将暂存的修改重新应用，可以看到以前暂存的修改又回来了git stash apply# 应用队列中某一暂存项git stash apply stash@{0} # 应用最近的暂存项git stash apply stash@{1} # 应用第二近的暂存项git stash apply stash@{2} # 应用第三近的暂存项# 依此类推 # 恢复暂存的修改，同时删除 stash 记录# git stash apply stash@{0} &amp;&amp; git stash drop stash@{0}git stash pop 参考博文： (5条消息) git stash暂存修改_大掌教的Cocos Creator研究院-CSDN博客 (2条消息) git 删除stash 的内容_csdnmuyi的博客-CSDN博客 git 给某次提交打上 tag &amp; 删除 tag9.1 打上 tag 1234567891011121314151617181920# 打上 tag 流程git add *git commit -am &quot;xxx&quot;# git pull 不仅会同步修改的内容还会同步 tagsgit pull# 只提交修改的内容，不会提交 taggit push # 给最近的提交打上 taggit tag v1.1.x # 只提交 tags，不会提交修改的内容# 会跟远程的 tags 进行比较，将所有新增的 tags 都推送到远程git push --tags # 只提交 tag，不会提交修改的内容# 将具体的某一个 tag 推送至远程git push origin v1.1.0 git push 是不包含 tag 的；如果想包含可以在 push 时加上 –tags 参数，但是此时只会提交 tag，不会提交修改的内容 git push –tags 与 git push origin v1.1.0 的区别在于 git push –tags 会跟远程的 tags 进行比较，将所有新增的 tags 都推送至远程（增量更新） git pull 不仅会同步修改的内容还会同步 tags 9.2 删除 tag 123# 移除 taggit tag -d v1.1.x # 删除本地 taggit push origin :refs/tags/v1.1.x # 删除远程 tag 参考博文： Git - 打标签 git 打tag标签_倒骑驴走着瞧的博客-CSDN博客_git打tag git删除tag - 极_地 - 博客园 git cherry-pick 将一个分支上的某些提交应用到另一个分支1234567891011121314151617181920212223242526272829# 切换到想要应用修改的分支 xxxgit checkout xxx# 应用一个分支的某一个提交到 xxx 分支git cherry-pick &lt;commit-id&gt;# 应用一个分支的多个提交到 xxx 分支，提交之间使用空格分隔git cherry-pick &lt;commit-id1&gt; &lt;commit-id2&gt; &lt;commit-id3&gt; ...# 应用一个分支中连续的多个提交到 xxx 分支# 此语法对应的操作区间是左开右闭，不包含 start-commit-id# 另外要注意这两个commit 之间要求有连续关系的，并且前者要在后者之前，顺序不能颠倒git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;# 应用一个分支中连续的多个提交到 xxx 分支# 此语法对应的操作区间是闭区间，包含 start-commit-idgit cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;# 应用该分支最近的提交到 xxx 分支git cherry-pick &lt;branch-name&gt;# cherry-pick 其它命令# 当 cherry-pick 多个提交时，假设遇到冲突：# --continue 继续进行下一个# --quit 结束 cherry-pick 操作，但是不会影响冲突之前多个提交中已经成功的# --abort 直接打回原形，回到 cherry-pick 前的状态，包括多个提交中已经成功的git cherry-pick --continue git cherry-pick --quit git cherry-pick --abort 参考博文： (5条消息) Git-用 cherry-pick 挑好看的小樱桃_段浅浅的博客-CSDN博客_git pick-cherry (2条消息) Git：cherry-pick应用一个分支某些现有提交，到另外一个分支_琦彦-CSDN博客 git 删除远程分支上的某次提交只讨论最简单也是最常用的一种情形： 删除最后一次提交（远程仓库版本回滚要提醒其它开发人员保存好自己本地的修改内容） 有两种方式 revert 和 reset 12345678910# revert 方式# 备份最后一次提交的内容git branch xxx # 从当前分支切一个新分支# 放弃指定提交的修改内容，但是会生成一次新的提交，需要填写提交注释，以前的提交记录都在# 放弃最后一次提交git revert HEAD# 将生成的新提交 commit 推送到远程git push 12345678910# reset 方式# 备份最后一次提交的内容git branch xxx # 从当前分支切一个新分支# 将 HEAD 指针指到指定提交，历史记录中不会出现放弃的提交记录# 让 HEAD 指针回到上一次的提交commit，即放弃最后一次提交git reset --hard HEAD^ || git reset --hard HEAD~1# reset 之后本地库落后于远程库一个版本，因此需要强制提交 -fgit push -f 参考博文： (2条消息) git 删除远程分支上的某次提交_张小强的专栏-CSDN博客_git删除远程某次提交 Git删除master branch中最近一次的提交 - 新西兰程序员 - 博客园 git 删除本地分支上的某次提交不讨论特别复杂的情况，仅考虑删除最后一次提交 12# 删除最后一次的提交记录，但是还保留提交所做的更改git reset --soft HEAD^ || git reset --soft HEAD~1 12# 删除最后一次的提交记录，并且不保留提交所做的更改git reset --hard HEAD^ || git reset --hard HEAD~1 参考博文： 【转】Git删除commit提交的log记录 - 程序小工 - 博客园 Git撤销本地commit_K.Sun-CSDN博客_git 删除本地commit git branch 删除分支 &amp; 恢复分支13.1 查看所有分支 12# 查看所有分支git branch -a 13.2 删除与恢复本地分支 1234567891011# 查看本地分支列表git branch# 删除本地分支git branch -d xxx # 删除不是当前分支的其它分支git branch -D xxx # 强制删除当前分支 # 恢复本地分支# 查找被删除分支的 commmit-idgit reflog# 恢复被删除的分支git branch xxx commit-id 13.3 删除本地的remotes分支 1234# 查看所有分支git branch -a# 删除本地的remotes分支git branch -r -d origin/xxx 13.4 删除远程分支 1234# 查看远程分支列表git branch -r# 删除远程分支git push origin --delete xxx 参考博文： Git删除分支/恢复分支 - uTank - 博客园 (18条消息) git命令行删除远程分支_枫竹梦-CSDN博客 git删除本地分支和远程分支 - 安静的小龙码 - 博客园 git 通过 tag 回退版本修复 bug背景：线上版本出现 bug，需要紧急修复这个 bug，然后马上发版本，可是这个时候代码的新功能已经开发到一半了，不能回退，遇见这种情况怎么办？ 参见上述博文，步骤如下： 14.1 当前分支回退到打 tag 的那次提交，比如回到 tag v1.0 对应的那次提交 获取 tag v1.0 对应的那次提交的 commit-id 1git show v1.0 对应的 commit-id 为 16c0866879541a489c83532ccbe7926984ad46d0 这一步也可以通过 Git Graph 等工具直接查看 回退到打 tag 的那次提交 1git reset --hard 16c0866879541a489c83532ccbe7926984ad46d0 14.2 创建新分支 xxx，备份当前内容 12# 创建新分支 xxxgit branch xxx 14.3 当前分支立即回到最近的一次提交 通过 git reflog 查看当前分支最近一次提交对应的 commit-id 12# 查看最近一次提交的 commit-idgit reflog 同样也可以通过 Git Graph 等工具查看当前分支最近一次提交的 commit-id 对应的 commit-id 为 271aa56c58ad00c8768e83b515f693f22ff2fe28 12# 回到最近一次提交git reset --hard 271aa56c58ad00c8768e83b515f693f22ff2fe28 14.4 切换到 xxx 分支，修改 bug，发版本，打新 tag 12# 切换到 xxx 分支git checkout xxx 注意这里的发版本是指开发人员自己发版，配置 nginx 等 1234# 修改完后打 tag git add *git commit -am &quot;fix: xxx&quot;git tag v1.4 // 打上新 tag 14.5 将 xxx 分支合并到主干 1234# 切换到 master 分支git checkout master# 将 xxx 分支合并到主干git merge xxx 有冲突处理冲突，再次提交 1234git add *git commit -am &quot;合并冲突&quot;git pullgit push 14.6 推送新 tag 到远程仓库 12# 将新 tag 推送至远程仓库git push --tags || git push origin v1.4 如此通过 tag 回退版本修复 bug 的整个流程就完成了，可继续保留本地分支 xxx ，以防需要再次进行修改 参考博文： Git高级教程 (一)] 通过Tag标签回退版本修复bug_梧桐那时雨-CSDN博客_git通过tag回退 git 恢复 git reset –hard xxx 之前的 commit-id 对应的内容与 14 不同，15 在 git reset –hard commit-id 操作之后，在当前分支上进行了修改 步骤如下： 15.1 暂存当前修改的内容 12# 暂存修改的内容git stash 15.2 使用 git reflog 或者查看 .git/logs/refs/heads/branch_name 文件找到想要回去的 commit-id 执行命令 git reflog 文件路径： .git/logs/refs/heads/branch_name 15.3 新建分支，恢复 git reset –hard 之前的 commit-id 对应的内容 12# 新建分支 branch_name，恢复 commit-id 对应的内容git checkout commit-id -b branch_name 参考博文： git reset –hard 回滚以后 以后怎么再回去？ - SegmentFault 思否 恢复git reset –hard之前的commit号 - HappyMrSpring - CSDN博客 版本回退 - 廖雪峰的官方网站","link":"/2021/12/07/git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/"},{"title":"自适应布局","text":"自适应布局实现有多种方式，下面仅列举我使用过的几种 一般而言，自适应布局常在PC端上应用，常常给html元素设置一个最小显示宽度 min-width，小于这个宽度部分元素被遮挡住（设置了overflow:hidden）或者浏览器底部出现横向滚动条。 CSS3 zoom 属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- index.html --&gt;&lt;!-- 运行结果: firefox 不能缩放、edge、chrome 可以缩放 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://necolas.github.io/normalize.css/latest/normalize.css&quot;&gt; &lt;title&gt;CSS ZOOM&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=&quot;height: 500px; width: 500px; background-color: black;&quot;&gt;&lt;/div&gt; &lt;script&gt; // js 部分代码如下 // 初始化 window.onload = function () { document.body.style.zoom = 'normal'; // 避免 zoom 尺寸叠加 let ratio = document.body.clientWidth / 1904; document.body.style.zoom = ratio; }; // 函数防抖 (function () { var throttle = function (type, name, obj) { obj = obj || window; var running = false; var func = function () { if (running) { return; } running = true; requestAnimationFrame(function () { obj.dispatchEvent(new CustomEvent(name)); running = false; }); }; obj.addEventListener(type, func); }; // 初始化 - 可以初始化任何事件 throttle('resize', 'optimizedResize'); })(); window.addEventListener('optimizedResize', function () { document.body.style.zoom = 'normal'; let ratio = document.body.clientWidth / 1904; document.body.style.zoom = ratio; }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; CSS3 transform:scale() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- index.html --&gt;&lt;!-- 运行结果: firefox 、edge、chrome 都可以缩放 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://necolas.github.io/normalize.css/latest/normalize.css&quot;&gt; &lt;title&gt;CSS SCALE&lt;/title&gt; &lt;/head&gt; &lt;!-- 缩放原点 --&gt; &lt;body style=&quot;transform-origin: 0 0;&quot;&gt; &lt;div style=&quot;height: 500px; width: 500px; background-color: black;&quot;&gt;&lt;/div&gt; &lt;script&gt; // js 部分代码如下 // 初始化 window.onload = function () { let radio = document.body.clientWidth / 1904; document.body.style.transform = `scale(${radio},${radio})` }; // 函数防抖 (function () { var throttle = function (type, name, obj) { obj = obj || window; var running = false; var func = function () { if (running) { return; } running = true; requestAnimationFrame(function () { obj.dispatchEvent(new CustomEvent(name)); running = false; }); }; obj.addEventListener(type, func); }; // 初始化 - 可以初始化任何事件 throttle('resize', 'optimizedResize'); })(); window.addEventListener('optimizedResize', function () { let radio = document.body.clientWidth / 1904; document.body.style.transform = `scale(${radio},${radio})` }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JS 计算缩放比例，对指定元素的布局属性按照缩放比例重新赋值用途不是很广泛，可用于对方案1和方案2中不随整体自适应的元素单独处理 12345678910111213let ratio = document.body.clientWidth / 1904;let element = document.getElementById('element');element.style.height = Math.round(618 * ratio) + 'px';element.style.width = Math.round(1365 * ratio) + 'px';element.style.marginTop = Math.round(-30 * ratio) + 'px';element.style.marginLeft = Math.round(65 * ratio) + 'px';// element 元素在 1920*1080 分辨率时的布局属性如下：// {// height: 618px;// width: 1365px;// margin-top: -30px;// margin-left: 65px;// } OminiBrowser 项目使用的自适应布局方式（兼容不同浏览器）因为这个项目是自己早期做的，存在很多疏漏，这里仅用作于参照这里当时并不知道 transform: scale() 可以兼容大多数浏览器；不过有一点值得注意的是：使用transform: scale() 进行缩放，会在 ie、edge 浏览器右侧和底部产生大片空白，这里使用了一些技巧进行处理，如设置overflow-x: hidden、计算出来的高度乘以0.9等 该方案结合了方案1和2，可兼容大部分浏览器，但是对于引入的 Element UI、vis 等插件会有影响，比如 el-select 下拉框位置漂移、图表不跟随此逻辑缩放等，这些问题需要自己再去做兼容处理 123456&lt;!-- index.html --&gt;&lt;body style=&quot;transform-origin: 0 0;&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; // js 部分代码如下 &lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var client = (function () { // 呈现引擎 var engine = { ie: 0, edge: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0 }; // 检测呈现引擎、平台和设备 var ua = navigator.userAgent; // 通过检测用户代理字符串 if (window.opera) { engine.opera = parseFloat(engine.ver); } else if (/AppleWebKit\\/(\\S+)/.test(ua) &amp;&amp; ua.indexOf('Edge/') === -1) { engine.webkit = parseFloat(engine.ver); } else if (/KHTML\\/(\\S+)/.test(ua) &amp;&amp; ua.indexOf('Edge/') === -1) { engine.khtml = parseFloat(engine.ver); } else if (/rv:([^)]+)\\) Gecko\\/\\d{8}/.test(ua) &amp;&amp; ua.indexOf('Edge/') === -1) { engine.gecko = parseFloat(engine.ver); } else if (!!window.ActiveXObject || 'ActiveXObject' in window) { engine.ie = parseFloat(engine.ver); } else if (ua.indexOf('Edge/') !== -1) { engine.edge = parseFloat(engine.ver); } return engine;})();// 1920 这里也并没有去掉滚动条的宽度，正确的宽度应该是 1920 - 16 = 1904// screen.width 取的是屏幕的像素宽度，等同于 window.screen.widthvar zoomRatio = 1920 / screen.width; Object.keys(client).forEach(function (key) { if (client[key] !== 0) { if (key === 'webkit') { // chrome, safari document.documentElement.style.zoom = 1 / zoomRatio; } else if (key === 'ie') { // ie document.body.style.zoom = 1 / zoomRatio; document.body.style.width = 100 * zoomRatio + '%'; // 设置为 0.9，是考虑到浏览器导航栏、书签栏的高度以及操作系统底部任务栏的高度，页面实际的高度并没有 1080 document.body.style.height = 0.9 * (1080 / zoomRatio) + 'px'; // 设置 body 的高度 document.documentElement.style.height = 0.9 * (1080 / zoomRatio) + 'px'; // 设置 html 元素的高度 document.documentElement.style.overflowX = 'hidden'; // 设置横向溢出隐藏 } else if (key === 'edge') { // edge document.body.style.zoom = 1 / zoomRatio; document.documentElement.style.height = 0.9 * (1080 / zoomRatio) + 'px'; document.documentElement.style.overflowX = 'hidden'; } else if (key === 'gecko') { // firefox document.body.style.transform = 'scale(' + 1 / zoomRatio + ',' + 1 / zoomRatio + ')'; document.body.style.width = 100 * zoomRatio + '%'; document.documentElement.style.height = 0.9 * (1080 / zoomRatio) + 'px'; } }}); rem 布局 rem 布局的关键点在于 html { font-size: 1vw } 即将 html 元素的 font-size 设置为 1vw，因为 rem 是基于页面根元素（即 html 元素）的 font-size 计算的，默认情况下，1rem = html 的 font-size 值；在这里就是 1rem = 1vw，因此当视宽 vw 发生变化时，以 rem 做单位的元素也会相应的变化 浮动布局与 rem 布局对比浮动布局代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://necolas.github.io/normalize.css/latest/normalize.css&quot;&gt; &lt;title&gt;浮动布局&lt;/title&gt; &lt;style&gt; .box { float: left; width: 400px; margin: 50px 25px; } .box p { width: 100%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box box1&quot;&gt; &lt;p&gt; 1，软件部培训总结撰写 √ 已完成 2，自己笔记本shenguyun文件夹整理 √ 已完成 3，面试经验总结（最后一个）√ 已完成 4，将各项目需要在53上面发版的步骤总结一下 差 Manage 发版内容，等明确了53 Manage 存放的地址加上即可 ui-app-android 项目配置文件路径 5，vivo手机文件同步（需要在同一wifi环境下安装手机驱动） &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box box2&quot;&gt; &lt;p&gt; 1，总结一下 8 月份暂未完成的任务 √ 已完成 2，自己笔记本上需要下载的东西下载好 公司电脑和自己的笔记本数据同步 1，软件部培训总结撰写 回去再写 √ 已完成 9/5 2，自己笔记本shenguyun文件夹整理 √ 已完成 9/5 3，chrome 书签备份 √ 4，公司文件夹shenguyun同步 √ 3，面试经验总结（最后一个）√ 已完成 9/5 4，浏览器书签内容整理 5，将各项目需要在53上面发版的步骤总结一下 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box box3&quot;&gt; &lt;p&gt; 苹果应用市场审核意见：您的应用程序使用第三方登录服务，但不提供Apple登录。使用第三方登录服务进行帐户身份验证的应用程序需要向用户提供使用Apple登录的同等选项。 下一步请修改您的应用程序，以提供与Apple登录作为帐户身份验证的等效选项。 将微信登陆按钮隐藏后去审核，审核通过之后，通过热更新将按钮换回来 上架审核时，可以给界面上的微信登录按钮 设置一个定时器里面设置微信登录按钮隐藏，以便通过审核 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 页面表现如下： 1366x768 1200x473 1080x473 ipad pro 1024x1366 960x473 ipad 768X1024 iphone6/7/8/plus 414x736 rem 布局代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://necolas.github.io/normalize.css/latest/normalize.css&quot;&gt; &lt;title&gt;rem 自适应布局&lt;/title&gt; &lt;style&gt; html { font-size: 1vw; } .box { float: left; width: 29rem; margin: 4rem 2rem 0rem 2rem; } .box p { width: 100%; /* font-size: 1rem; */ /* 继承了html元素的font-size值 大致为 13.66px */ } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box box1&quot;&gt; &lt;p&gt; 1，软件部培训总结撰写 √ 已完成 2，自己笔记本shenguyun文件夹整理 √ 已完成 3，面试经验总结（最后一个）√ 已完成 4，将各项目需要在53上面发版的步骤总结一下 差 Manage 发版内容，等明确了53 Manage 存放的地址加上即可 ui-app-android 项目配置文件路径 5，vivo手机文件同步（需要在同一wifi环境下安装手机驱动） &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box box2&quot;&gt; &lt;p&gt; 1，总结一下 8 月份暂未完成的任务 √ 已完成 2，自己笔记本上需要下载的东西下载好 公司电脑和自己的笔记本数据同步 1，软件部培训总结撰写 回去再写 √ 已完成 9/5 2，自己笔记本shenguyun文件夹整理 √ 已完成 9/5 3，chrome 书签备份 √ 4，公司文件夹shenguyun同步 √ 3，面试经验总结（最后一个）√ 已完成 9/5 4，浏览器书签内容整理 5，将各项目需要在53上面发版的步骤总结一下 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box box3&quot;&gt; &lt;p&gt; 苹果应用市场审核意见：您的应用程序使用第三方登录服务，但不提供Apple登录。使用第三方登录服务进行帐户身份验证的应用程序需要向用户提供使用Apple登录的同等选项。 下一步请修改您的应用程序，以提供与Apple登录作为帐户身份验证的等效选项。 将微信登陆按钮隐藏后去审核，审核通过之后，通过热更新将按钮换回来 上架审核时，可以给界面上的微信登录按钮 设置一个定时器里面设置微信登录按钮隐藏，以便通过审核 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1366x768 1200x473 1080x473 ipad pro 1024x1366 960x473 ipad 768X1024 iphone6/7/8/plus 414x736 对比效果很明显，rem 布局在自适应上更具优势","link":"/2021/12/05/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"},{"title":"React Native 0.66 Demo 搭建全过程（Android）","text":"开发环境搭建（Android）本文 Demo 是在 Windows 10 - 64位系统上搭建的。 搭建开发环境 · React Native 中文网 参照上述博文，需要安装的软件 123Node v12.22.0JDK jdk1.8.0_221Android Studio v4.2.2 安装 Node可参照下面的博文安装 nvm，通过 nvm 来安装 node 、管理 node 版本 nvm 安装与使用 - Admvli2016’s Blog 1.1.1 安装 Yarn 12# 安装 yarnnpm install -g yarn 安装 JDKJDK 需要安装 1.8.x 版本的 （1）下载安装包（我的是 jdk-8u221-windows-x64.exe） （2）安装过程不再赘述，更改文件安装目录 D:\\ShenGuYun\\Java\\jdk1.8.0_221\\，然后一步一步安装即可 （3）打开 cmd 查看 JDK 版本号，验证是否安装成功 12# 查看 JDK 版本号java -version （4）JDK 环境变量配置 添加系统变量 JAVA_HOME PATH变量添加下面一条记录: %JAVA_HOME%\\bin 添加系统变量 CLASSPATH: .;%JAVA_HOME%\\lib; （注：如存在这个环境变量，需要检查） 安装 Android Studio（1）Android Studio 安装过程 安装界面勾选 Android Virtual Device 然后一直 Next 即可 点击 Finish，会弹出下面的弹框，选择 Do not import settings 接下来可以看到欢迎界面 点击 Next，选择 Standard 接下来一直 Next 即可，Android Studio 会自动下载开发所需的组件（需要打开 VPN） 下载完成，点击 Finish 至此 Android Studio 安装完成 （2）下载 Android SDK Android Studio 安装完成后可以看见如下界面： 打开 SDK Manager SDK Manager 还可以在 Android Studio 的 “Preferences” 菜单中找到。 具体路径是 Appearance &amp; Behavior → System Settings → Android SDK。 确保勾选了下面这些组件 Android SDK Platform 29 Intel x86 Atom_64 System Image 然后点击 SDK Tools 选项卡 还是在 SDK Tools 选项卡 最后点击 “Apply” 来下载和安装这些组件选择 Accept 点击 Next （3）配置 ANDROID_HOME 环境变量 因为我之前搭建 ionic5.x Demo 时，已经配置过 ANDROID_HOME 环境变量，这里就不需要再进行处理了。 在 Android Studio 的 “Preferences” 菜单中查看 SDK 的真实路径，具体是 Appearance &amp; Behavior → System Settings → Android SDK。 查看到的 SDK 路径也是之前配置过的 SDK 路径 D:\\ShenGuYun\\Software\\Android\\android-sdk （4）将一些工具目录添加到环境变量 Path 中 如下所示： 1234%ANDROID_HOME%\\platform-tools%ANDROID_HOME%\\emulator%ANDROID_HOME%\\tools%ANDROID_HOME%\\tools\\bin 重启电脑使环境变量生效。 创建 React Native 项目 如果之前全局安装过旧的 react-native-cli 命令行工具，请使用 npm uninstall -g react-native-cli 卸载掉它以避免一些冲突。 使用 React Native 内建的命令行工具来创建一个名为 “react-native-demo” 的新项目。这个命令行工具不需要安装，可以直接用 node 自带的 npx 命令来使用： 必须要看的注意事项一：请不要在目录、文件名中使用中文、空格等特殊符号。请不要单独使用常见的关键字作为项目名（如 class, native, new, package 等等）。请不要使用与核心模块同名的项目名（如 react, react-native 等）。 必须要看的注意事项二：请不要在某些权限敏感的目录例如 System32 目录中 init 项目！会有各种权限限制导致不能运行！ 必须要看的注意事项三：请不要使用一些移植的终端环境，例如 git bash 或 mingw 等等，这些在 windows 下可能导致找不到环境变量。请使用系统自带的命令行（CMD 或 powershell）运行。 12345678# 创建新项目npx react-native init react-native-demonpx react-native init my-react-native-demo# 前面这两个创建报错# 项目名称不合法 'xxx is not a valid name for a project'npx react-native init MyReactNativeDemo# 使用 MyReactNativeDemo 就创建成功了（Pascal命名：大驼峰命名法）# 未使用带 typescript 配置的，正式开发时需要使用 typescript [可选参数] 指定版本或项目模板 可以使用 --version 参数（注意是两个杠）创建指定版本的项目。注意版本号必须精确到两个小数点。(指定 React-Native 的版本) 1npx react-native init MyReactNativeDemo --version X.XX.X 还可以使用 --template 来使用一些社区提供的模板，例如带有 TypeScript 配置的： 1npx react-native init MyReactNativeDemo --template react-native-template-typescript 运行 React Native 项目准备 Android 设备 (真机)以我的手机 vivo x23 为例 （1）打开 USB 调试 设置 &gt; 系统管理 &gt; 开发者选项 &gt; 打开开发者选项 &amp;&amp; USB 调试 （2）通过 USB 数据线连接设备 检查设备是否能够正确连接到 ADB（Android Debug Bridge），使用 adb devices 命令： 过程中手机会弹出如下提示： 允许 USB 调试吗？ 点击确定即可。 adb devices 运行结果如下所示： 在右边那列看到 device 说明设备已经被正确连接了。注意，每次只应当连接一个设备。 译注：如果你连接了多个设备（包含模拟器在内），后续的一些操作可能会失败。拔掉不需要的设备，或者关掉模拟器，确保 adb devices 的输出只有一个是连接状态。 （3）运行项目 12# 运行项目npx react-native run-android 提示：还可以运行 npx react-native run-android --variant=release 来安装 release 版的应用。当然需要先配置好签名，且此时无法再开启开发者菜单。注意在 debug 和 release 版本间来回切换安装时可能会报错签名不匹配，此时需要先卸载前一个版本再尝试安装。 准备 Android 设备（模拟器）（1）使用 Android Studio 打开 MyReactNativeDemo 项目下的 android 目录 注意使用 Android Studio 打开项目时，需要关闭 VPN 出现报错： Cannot start react-native run-ios or run-android after initializing · Issue #31284 · facebook/react-native 参照上述博文，是因为 node 版本的问题 12# 切换 node 版本到 v12.22.0nvm use 12.22.0 关闭项目 Close Project，重新打开 解决问题！ （2）使用 AVD Manager 查看可用的虚拟设备，它的图标看起来像下面这样： 点击 AVD Manager （3）创建一个模拟设备 点击 “Create Virtual Device…” 然后选择所需的设备类型，点击 “Next” 然后选择 Q (API Level 29 image) 点击 Download（此时需要打开 VPN） 下载完成后点击 Finish 然后点击 “Next” 点击 “Finish” 点击 ▸ 运行 运行结果: 译注：请不要轻易点击 Android Studio 中可能弹出的建议更新项目中某依赖项的建议，否则可能导致无法运行。 运行 React Native 项目 (使用真机)此时需要打开 VPN 执行以下命令 123456# 打开项目文件夹cd MyReactNativeDemo# 运行项目yarn android # 或者 yarn react-native run-android # 或者 npx react-native run-android 此命令会对项目的原生部分进行编译，同时在另外一个命令行中启动 Metro 服务对 js 代码进行实时打包处理（类似 Webpack）。Metro 服务也可以使用 yarn start 命令单独启动。 使用模拟器运行项目执行命令同上，不过需要先打开模拟器 模拟器运行结果如图所示： 修改项目中代码（1）使用 VS Code 打开 App.js 文件并进行修改 （2）在 VS Code 中按 Ctrl + S 保存，就可以看到最新的修改 修改结果： 调试 React Native 项目注意以下操作都是使用真机调试，若使用模拟器，步骤基本一致。 开发菜单 开发菜单包括：Reload、Change Bundle Location、Show / Hide Element Inspector、Enable / Disable Fast Refresh、Show / Hide Perf Monitor、Settings、Enable / Disable Sampling Profiler、Debug 等 （1）Reload - 重新加载 App （2）Change Bundle Location 更改 Bundle 的位置，可用于更改远程调试地址（debugger-ui） （3）Show / Hide Element Inspector Inspect（审查元素） Touchables（查看可点击区域） Perf（性能分析工具，需要配合 Chrome 开发者工具的 Performance） Network（查看网络请求相关信息，需要配合 Chrome 开发者工具的 Network 使用） （4）Enable / Disable Fast Refresh - 启用 / 禁用热重载 （5）Show / Hide Perf Monitor 打开允许显示在其他应用的上层 开启一个悬浮层，其中会显示应用的当前帧数 （6）Settings 开发调试的一些设置 （7）Enable / Disable Sampling Profiler - 启用 / 禁用 取样分析器（貌似不能用） JSIExecutor+JSCRuntimedoes not support Sampling Profiler （8）Debug - 打开 Debug 模式 Chrome 开发者工具（debugger-ui）（1）debugger-ui 使用步骤 调试 · React Native 中文网 React Native开发和调试工具 - 掘金 React Native调试技巧与心得 - 黑乌鸦 - 博客园 参照上述博文 完整步骤： 将设备通过 USB 数据线连接到电脑上，并开启 USB 调试（关于如何开启 USB 调试，参见上面的章节）。 在 VS Code 中运行项目 yarn android 另外打开一个 cmd 窗口，运行 adb reverse tcp:8081 tcp:8081 在弹出 Packager（metro）命令窗口中敲击 d，唤出开发菜单，再点击 Debug 如上图所示 r 重载 app，d 打开 app 开发菜单 此时可以在 Packager（metro）命令窗口中看到如下提示 且 app 将会刷新一下页面 点击打开 Debug 的同时将会自动打开调试页面 http://localhost:8081/debugger-ui 如下图所示，说明 Debug 模式已开启！ 在 Chrome 中按 F12 打开开发者工具，就可以在 Chrome 中调试 JavaScript 代码了。 在 Console 中可以看到 RN 项目中打印的信息 注意：Chrome 中并不能直接看到 App 的用户界面，而只能提供 console 的输出，以及在 sources 项中断点调试 js 脚本。一些老的教程和文章会提到 React 的 Chrome 插件，这一插件目前并不支持 React Native，而且调试本身并不需要这个插件。不过可以安装独立（非插件）版本的 React Developer Tools 来辅助查看界面布局，下文会讲述具体安装方法 注意：使用 Chrome 调试目前无法观测到 React Native 中的网络请求，你可以使用功能更强大的第三方的 react-native-debugger 或是官方的 flipper（注意仅能在 0.62 以上版本可用）来观测。 在 Source 中调试 js - 全局断点 Pause On Caught Exceptions JavaScript: Is there a way to get Chrome to break on all errors? - Stack Overflow （2）Trouble Shooting 问题1：点击打开 Debug，App 报错：Failed to connect to debugger! Timeout while connecting to remote debugger 原因是 8081 端口被占用了，导致连接不上。 解决方法： 解决React Native端口号修改的方法 / 张生荣 参照上述博文，尝试修改 RN 本地运行的端口号 第一种方法不可行，运行如下命令将会自动打开一个 Packager 窗口 12# 将 apk 部署到手机上npx react-native run-android 使用 npx react-native start --port 9999 打开的 Packager 窗口和部署在手机上的 App 没有关联，所以不可行 摸索出来的正确修改 RN 本地运行端口号的办法 使用 yarn android --port 9999 运行项目，将 apk 部署到手机上 在自动打开的 Packager 命令窗口中，按 d 唤出开发菜单 选择 Change Bundle Location ，打开弹窗，输入 localhost:9999，点击确定 重新唤出开发菜单，选择 Debug，开启 Debug 模式，此时自动打开的调试页面地址为 http://localhost:9999/debugger-ui 开了两个前端服务（占用 8080、8081）验证一下上述方法是否管用 在 9998 端口上验证了一下，上述方法确实是可行的。 观察到一个现象： 发现启用一个前端服务（占用 8081）之后，使用 yarn android 运行项目，打不开 Packager 页面，并且安装到手机上的 app，打开后直接报错： 说明运行 yarn android 默认占用的是 8081 端口 问题2：debugger-ui 页面显示 Status: Another debugger is already connected reactjs - React Native localhost Another debugger is already connected - Stack Overflow 参照上述博文，原因是 Chrome 有两个标签页同时访问了 http://localhost:8081/debugger-ui/ 或者 IE、Edge 和 Chrome 浏览器同时访问了 http://localhost:8081/debugger-ui/ 问题3：Packager 命令窗口报错：Error: Unable to resolve module ./debugger-ui/ui.e31bb0bc.js App 上同时警告： Remote debugger is in a background… 完整内容： 12Console WarningRemote debugger is in a background tab which may cause apps to perform slowly. Fix this by foregrounding this tab (or opening it in a separate window). 控制台警告：远程调试器位于后台选项卡中，这可能会导致应用程序执行缓慢。通过激活该选项卡（或在单独的窗口中打开）修复此问题。 该报错不会影响 Debug 调试功能正常使用，可不作理会。 问题4：点击打开 Debug，App 报错：Attempt to invoke interface method 'java.lang.String.com.facebook.react.bridge.CatalystInstance.getSourceURL()' on a null object reference 在开发菜单 Settings 页面设置 Debugging &gt; Debug server host &amp; port for device；然后再点击打开 Debug 会报这个错误，注意一下即可。 react-devtools12# 全局安装 npm install -g react-devtools react/packages/react-devtools at main · facebook/react 参照上述博文 完整步骤： 将设备通过 USB 数据线连接到电脑上，并开启 USB 调试 在 VS Code 中运行项目 yarn android 启动 react-devtools：打开一个 cmd 窗口，运行命令 react-devtools 运行在真机上时，需要继续执行以下命令 1adb reverse tcp:8097 tcp:8097 在弹出 Packager（metro）命令窗口中敲击 d，唤出开发菜单，再点击 Show Element Inspector 即可。 在 react-devtools 当中选中一个元素（类似于 Chrome 开发者工具中 Elements 的作用） 手机端同时选中了相同的元素。 React Native Debugger（1）安装 React Native Debugger GitHub： jhen0409/react-native-debugger: The standalone app based on official debugger of React Native, and includes React Inspector / Redux DevTools 下载页：Releases · jhen0409/react-native-debugger 下载安装包，选择合适位置解压即可。 （2）React Native Debugger 调试注意事项 react-native-debugger/getting-started.md at master · jhen0409/react-native-debugger 参照上述博文，调试时有以下几点需要注意： 确保所有 React Native 的调试客户端都已经关闭，如 debugger-ui 确保 React Native Debugger 已打开且处于等待状态 React Native Debugger 将尝试连接调试器代理，默认使用 8081 端口，如果需要，可以创建一个指定端口的新的调试器窗口（macOS: comand+ T，Linux/Windows: Ctrl+T） 打开开发菜单，点击 Debug，将会自动启用 React Native Debugger （3）React Native Debugger 使用步骤总结 RN调试利器——React Native Debugger【图文】_mob604756fdc4e1_51CTO博客 (11条消息) 如何使用React Native Debugger来调试 而不使用RN默认的debugger-ui_hzxOnlineOk的博客-CSDN博客_debugger-ui react-native-debugger 调试工具简单使用 · Fish Mobile X 参照上述博文 完整步骤： 将设备通过 USB 数据线连接到电脑上，并开启 USB 调试 在 VS Code 中运行项目 yarn android 打开下载好的 React Native Debugger，确保所有 React Native 的调试客户端都已经关闭，如 debugger-ui 在弹出 Packager（metro）命令窗口中敲击 d，唤出开发菜单，再点击 Debug 即可。 此时可以在 Packager（metro）命令窗口中看到如下提示 且 app 刷新了一下页面，说明 Debug 模式已开启！ 在 React Native Debugger 界面中可以看到上来的内容： （4）Trouble Shooting 问题：React Native Debugger v0.12.1 看不到 React Native Style Editor 部分 react-native-debugger/react-devtools-integration.md at master · jhen0409/react-native-debugger Selective dependency resolutions Yarn React DevTools: Unsupported backend version 参见上述博文，以为是 react-devtools-core 版本的问题 在自己的项目 package.json 里面加了下面一句 123&quot;resolutions&quot;: { &quot;react-devtools-core&quot;: &quot;~4.13.5&quot;}, 然后运行了一下 yarn install ，没有任何作用，react-devtools-core 也删不掉了。 其实上面的博文和自己遇见的问题根本不一样，自己没有仔细看。 找到另外一篇博文 cant see Native Style Editor · Issue #569 · jhen0409/react-native-debugger 参见上述博文，真正的原因是 react-devtools 版本的问题，最新版本的 react-devtools 不提供 React Native Style Editor 功能 这部分平常不怎么用到，对开发没有太大影响，也可以使用内置工具 Show Element Inspector 来替代 React Native 项目打包打包发布 · React Native 中文网 为应用签名 Android 开发者 Android Developers 参照上述博文，首先需要配置好应用签名。 生成一个签名密钥可以用 keytool 命令生成一个私有密钥。在 Windows 上 keytool 命令放在 JDK 的 bin 目录中（我的是 D:\\ShenGuYun\\Software\\Java\\jdk1.8.0_221\\bin），需要在命令行中先进入此目录才能执行下列命令。 1keytool -genkeypair -v -storetype PKCS12 -keystore my-release-key.keystore -alias com.xxxxxxx.xxxxxx -keyalg RSA -keysize 2048 -validity 1000 这条命令会要求你输入密钥库（keystore）和对应密钥的密码 1234# 密钥库（keystore）密码xx123456# 对应密钥的密码xx123456 然后设置一些发行相关的信息 最后它会生成一个叫做 my-release-key.keystore 的密钥库文件。 生成的文件路径： D:\\ShenGuYun\\Software\\Java\\jdk1.8.0_221\\bin\\my-release-key.keystore 在运行上面这条语句之后，密钥库里应该已经生成了一个单独的密钥，有效期为 10000 天。 --alias 参数后面的别名是将来为应用签名时所需要用到的，所以记得记录一下这个别名。 12// 别名com.xxxxxxx.xxxxxx 注意：请记得妥善地保管好密钥库文件，一般不要上传到版本库或者其它的地方。 设置 gradle 变量（1）把 my-release-key.keystore 文件放到工程中的 android/app 文件夹下。 （2）编辑 ~/.gradle/gradle.properties（全局配置，对所有项目有效）或是 项目目录/android/gradle.properties（项目配置，只对所在项目有效）。如果没有 gradle.properties 文件就自己创建一个，添加如下的代码（注意把其中的 **** 替换为相应密码） 注意：~ 符号表示用户目录，比如 windows 上可能是 C:\\Users\\用户名，而 mac 上可能是 /Users/用户名。 12345# Signature applicationMYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=com.xxxxxxx.xxxxxxMYAPP_RELEASE_STORE_PASSWORD=xx123456MYAPP_RELEASE_KEY_PASSWORD=xx123456 上面的这些会作为 gradle 的变量，在后面的步骤中可以用来给应用签名。 将签名配置添加到项目的 gradle 配置中编辑项目目录下的 android/app/build.gradle 文件 123456789101112131415161718192021222324252627282930// android/app/build.gradleandroid { ... defaultConfig { ... // applicationId &quot;com.myreactnativedemo&quot; applicationId &quot;com.xxxxxxx.xxxxxx&quot; } signingConfigs { ... release { if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) { storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD } } } buildTypes { release { ... // signingConfig signingConfigs.debug signingConfig signingConfigs.release } }} 修改应用名称以及应用图标我算是从安装到打包完成了一个 React Native 项目 - SegmentFault 思否 参照上述博文 （1）修改应用名称 文件路径：/android/app/src/main/res/values/strings.xml 123&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;因思云&lt;/string&gt;&lt;/resources&gt; （2）修改应用图标 将下列文件夹下的图标替换成需要的 Icon 即可。 文件夹路径：/android/app/src/main/res/ 生成发行 APK 包只需在终端中执行以下命令： 12cd android./gradlew assembleRelease 译注：cd android 表示进入 android 目录（如果已经在 android 目录中了那就不用输入了）。./gradlew assembleRelease 在 macOS、Linux 或是 windows 的 PowerShell 环境中表示执行当前目录下的名为 gradlew 的脚本文件，且其运行参数为 assembleRelease，注意这个 ./ 不可省略；而在 windows 的传统 CMD 命令行下则需要去掉 ./。 Gradle 的 assembleRelease 参数会把所有用到的 JavaScript 代码都打包到一起，然后内置到 APK 包中。如果想调整下这个行为（比如 js 代码以及静态资源打包的默认文件名或是目录结构等），可以看看 android/app/build.gradle 文件，然后琢磨下应该怎么修改以满足需求。 注意：请确保 gradle.properties 中 没有 包含 _org.gradle.configureondemand=true_ ，否则会跳过 js 打包的步骤，导致最终生成的是一个无法运行的空壳。 生成的 APK 文件位于 android/app/build/outputs/apk/release/app-release.apk ，它已经可以用来发布了。 运行 gradlew assembleRelease 报错： 猜测是因为 node 版本问题，切换至 node v12.22.0 再次尝试运行 gradlew assembleRelease，注意此时需要打开 VPN 打包成功！确实是 node 版本问题 生成的 apk 文件如下图所示： 文件路径：xxx\\MyReactNativeDemo\\android\\app\\build\\outputs\\apk\\release\\app-release.apk 将 APK 安装到手机上（1）直接安装 APK，可以正常使用 （2）命令形式安装 输入以下命令可以在设备上安装发行版本 APK： 1234# 打开项目文件夹cd MyReactNativeDemo# 安装发行版本 APKnpx react-native run-android --variant=release 注意 --variant=release 参数只能在完成了上面的签名配置之后才可以使用。 注意：在 debug 和 release 版本间来回切换安装时可能会报错签名不匹配，此时需要先卸载前一个版本再尝试安装。 安装到手机上成功。 可以看到运行有报错： 应该是之前更改了 applicationId 的问题，改回来 123456789// android/app/build.gradleandroid { ... defaultConfig { ... applicationId &quot;com.myreactnativedemo&quot; // applicationId &quot;com.xxxxxxx.xxxxxx&quot; } } 再次执行 12# 安装发行版本 APKnpx react-native run-android --variant=release 没有报错了！ 针对不同的 CPU 架构生成 APK 以减小 APK 文件的大小默认情况下，生成的 APK 会同时包含针对于多种 CPU 架构的原生代码。这样可以让我们更方便的向其他人分享这个 APK，因为它几乎可以运行在所有的 Android 设备上。但是，这会导致所有设备上都有一些根本不会运行的代码，白白占据了空间。目前安卓设备绝大多数是 ARM 架构，因此对于大部分应用来说可以考虑去掉 x86 架构的支持（但是请注意模拟器大部分是 x86 架构，因此去掉 x86 架构后将无法在模拟器上运行）。 可以在 android/app/build.gradle 中修改如下代码（false 改为 true）来生成多个针对不同 CPU 架构的 APK。 123456789// android/app/build.gradlesplits { abi { reset() enable enableSeparateBuildPerCPUArchitecture universalApk false // If true, also generate a universal APK include &quot;armeabi-v7a&quot;, &quot;x86&quot;, &quot;arm64-v8a&quot;, &quot;x86_64&quot; // 注意这里 } } 123// android/app/build.gradle// def enableSeparateBuildPerCPUArchitecture = falsedef enableSeparateBuildPerCPUArchitecture = true 可以把这上面打包生成的多个 APK 都上传到支持对用户设备 CPU 架构定位的应用程序商店，例如 Google Play 和 Amazon AppStore，用户将自动获得相应的 APK。如果您想上传到其他市场，例如 APKFiles（不支持一个应用有多个 APK 文件），可以修改下面的代码，来额外生成一个适用不同 CPU 架构的通用 APK。 12345678910// android/app/build.gradlesplits { abi { reset() enable enableSeparateBuildPerCPUArchitecture // universalApk false universalApk true // 额外生成一个适用不同CPU架构的通用APK include &quot;armeabi-v7a&quot;, &quot;x86&quot;, &quot;arm64-v8a&quot;, &quot;x86_64&quot; } } 启用 Proguard 来减少 APK 的大小（可选）Proguard 是一个 Java 字节码混淆压缩工具，它可以移除掉 React Native Java（和它的依赖库中）中没有被使用到的部分，最终有效的减少 APK 的大小。 重要：启用 Proguard 之后，必须再次全面地测试你的应用。Proguard 有时候需要为你引入的每个原生库做一些额外的配置。参见 app/proguard-rules.pro 文件。 要启用 Proguard，修改 android/app/build.gradle 文件如下内容： 123456// android/app/build.gradle/** * Run Proguard to shrink the Java bytecode in release builds. */// def enableProguardInReleaseBuilds = falsedef enableProguardInReleaseBuilds = true","link":"/2021/12/24/React-Native-0-66-Demo-%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%88Android%EF%BC%89/"},{"title":"React Navigation 6.x 文档简述","text":"React Navigation 入门1.1 安装 @react-navigation/native 12# 安装导航库npm install @react-navigation/native 报错： 版本要求 react-native &gt;= 0.63.0 typescript&gt;= 4.1.0 typescript 版本太低，升级 typescript 版本就行 12npm uninstall typescriptnpm install --save-dev typescript 再次安装 1npm install @react-navigation/native 1.2 安装其他相关的依赖 12# 安装其他相关的依赖npm install react-native-screens react-native-safe-area-context iOS 从 React Native 0.60 及更高版本开始，不需要运行 react-native link如果使用的是 Mac 开发 iOS 应用，则需要 pod-install（通过Cocoapods）以完成链接。 1npx pod-install ios Android 需要一个额外的配置步骤：编辑 MainActivity.java 文件位置： android/app/src/main/java/&lt;your package name&gt;/MainActivity.java 将以下代码添加至 MainActivity 类的内部: 1234@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(null);} 并下面这一句放在文件开头位置 1import android.os.Bundle; 1.3 在项目中使用 NavigationContainer 123456789// 将下列语句放到 app.tsx 中import * as React from 'react';import { NavigationContainer } from '@react-navigation/native';export default function App() { return ( &lt;NavigationContainer&gt;{/* Rest of your app code */}&lt;/NavigationContainer&gt; );} 1.4 安装 @react-navigation/native-stack 12# 安装 @react-navigation/native-stacknpm install @react-navigation/native-stack 1.5 在项目中使用 createNativeStackNavigator 、 Stack.Navigator 、Stack.Screen 12345678910111213141516171819202122232425262728// In App.js in a new projectimport * as React from 'react';import { View, Text } from 'react-native';import { NavigationContainer } from '@react-navigation/native';import { createNativeStackNavigator } from '@react-navigation/native-stack';function HomeScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; );}const Stack = createNativeStackNavigator();function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );}export default App; 1.6 在项目中使用 initialRouteName 配置堆栈的初始路由 1234567891011121314151617181920212223242526272829303132333435import * as React from 'react';import { View, Text } from 'react-native';import { NavigationContainer } from '@react-navigation/native';import { createNativeStackNavigator } from '@react-navigation/native-stack';function HomeScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; );}function DetailsScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;/View&gt; );}const Stack = createNativeStackNavigator();function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator initialRouteName=&quot;Details&quot;&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;Stack.Screen name=&quot;Details&quot; component={DetailsScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );}export default App; 修改 initialRouteName 后需要重新加载项目，快速刷新对修改 initialRouteName 不起作用（不会生效） 需要说明的是，component 属性接收的是组件而不是一个 render() 方法。所以不要给它传递一个内联函数（比如 component={()=&gt; }）,否则你的组件在被卸载并再次加载的时候将会丢失所有的 state。 1.7 设置 option 参数 导航器中的每一个路由页面都可以设置一些参数，例如 title 1234&lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ title: 'Overview' }}/&gt; 如果要传递一些额外的属性，还可以使用一个 render 函数替换 component 属性，如下所示 123&lt;Stack.Screen name=&quot;Home&quot;&gt; {props =&gt; &lt;HomeScreen {...props} extraData={someData} /&gt;}&lt;/Stack.Screen&gt; 这种方式被称之为渲染回调 注意：默认情况下，React Navigation 会对屏幕组件应用优化措施以防止不必要的渲染。使用渲染回调将应用不了这些优化。因此，如果您使用渲染回调，则需要确保对屏幕组件使用 React.memo 或 React.PureComponent 以避免性能问题。 路由栈跳转Web 路由的跳转方式 1234567891011// 方式一&lt;a href=&quot;details.html&quot;&gt;Go to Details&lt;/a&gt;// 方式二&lt;a onClick={() =&gt; { window.location.href = 'details.html'; }}&gt; Go to Details&lt;/a&gt; 2.1 跳转到一个新页面 123456789101112131415161718import * as React from 'react';import { Button, View, Text } from 'react-native';import { NavigationContainer } from '@react-navigation/native';import { createStackNavigator } from '@react-navigation/stack';function HomeScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details&quot; onPress={() =&gt; navigation.navigate('Details')} /&gt; &lt;/View&gt; );}// ... other code from the previous section navigation ：在堆栈导航器中，navigation 属性会被传递到每一个 screen 组件中。 navigate() ： 我们调用 navigate 方法来实现页面的跳转。 2.2 多次跳转到同一路由 1234567891011function DetailsScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details... again&quot; onPress={() =&gt; navigation.navigate('Details')} /&gt; &lt;/View&gt; );} 运行上面的代码，当点击 Go to Details… again 时，什么事情都不会发生，这是因为我们已经在 Details 页面了。 现在假设一下，如果我们想要添加另一个 Details 页面呢？这是一个很常见的场景，在这个场景中我们想在同一个 Details 页面展示不同的数据。为了实现这个 ，我们可以用 push() 方法来替代 navigate() 方法，push() 方法可以直接向堆栈中添加新的路由而无视当前导航历史。 1234&lt;Button title=&quot;Go to Details... again&quot; onPress={() =&gt; navigation.push('Details')}/&gt; 2.3 路由返回 堆栈导航器提供的导航头默认包含一个返回按钮，点击按钮可以返回到上一个页面，如果导航堆栈中只有一个页面，也就是说并没有可以返回的页面的时候，这个回退按钮就不显示。 如果我们使用的是自定义的导航头，可以使用 navigation.goBack() 方法来实现路由返回，如下所示。 12345678910111213function DetailsScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details... again&quot; onPress={() =&gt; navigation.push('Details')} /&gt; &lt;Button title=&quot;Go to Home&quot; onPress={() =&gt; navigation.navigate('Home')} /&gt; &lt;Button title=&quot;Go back&quot; onPress={() =&gt; navigation.goBack()} /&gt; &lt;/View&gt; );} 另一个常见的需求就是返回到多个页面之前。比如，如果你的堆栈中有多个页面，你想依次移除页面然后返回到第一个页面上。在上面的场景中，我们想要返回Home 页面，所以我们可以使用 navigate('Home')。 另一种方法就是 navigation.popToTop()，这个方法将会返回到堆栈中的第一个页面上（初始页面），如下所示。 1234567891011121314151617function DetailsScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details... again&quot; onPress={() =&gt; navigation.push('Details')} /&gt; &lt;Button title=&quot;Go to Home&quot; onPress={() =&gt; navigation.navigate('Home')} /&gt; &lt;Button title=&quot;Go back&quot; onPress={() =&gt; navigation.goBack()} /&gt; &lt;Button title=&quot;Go back to first screen in stack&quot; onPress={() =&gt; navigation.popToTop()} /&gt; &lt;/View&gt; );} 路由传参3.1 基本用法 在页面跳转的过程中，免不了会进行数据的传递。在React Navigation中，路由之间传递参数主要有两种方式： 将参数封装成一个对象，然后将这个对象作为 navigation.navigate()、navigation.push() 方法的第二个参数，从而实现路由跳转参数的传递。 使用 route.params 读取传递过来的参数。 不管是哪种方式，我们建议对需要传递的数据进行序列化？？？，如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import * as React from 'react';import { Text, View, Button } from 'react-native';import { NavigationContainer } from '@react-navigation/native';import { createStackNavigator } from '@react-navigation/stack';function HomeScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details&quot; onPress={() =&gt; { /* 1. Navigate to the Details route with params */ navigation.navigate('Details', { itemId: 86, otherParam: 'anything you want here', }); }} /&gt; &lt;/View&gt; );}function DetailsScreen({ route, navigation }) { /* 2. Get the param */ const {itemId, otherParam} = route.params; return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Text&gt;itemId: {JSON.stringify(itemId)}&lt;/Text&gt; &lt;Text&gt;otherParam: {JSON.stringify(otherParam)}&lt;/Text&gt; &lt;Button title=&quot;Go to Details... again&quot; onPress={() =&gt; navigation.push('Details', { itemId: Math.floor(Math.random() * 100), }) } /&gt; &lt;Button title=&quot;Go to Home&quot; onPress={() =&gt; navigation.navigate('Home')} /&gt; &lt;Button title=&quot;Go back&quot; onPress={() =&gt; navigation.goBack()} /&gt; &lt;/View&gt; );}const Stack = createStackNavigator();export default function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;Stack.Screen name=&quot;Details&quot; component={DetailsScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );} 3.2 更新参数 在路由到的页面上也可以更新这些参数，navigation.setParams()方法就是用来更新这些参数的。 123navigation.setParams({ query: 'someText',}); 此方法必须要在路由到的页面组件挂载之后再进行调用 如下所示 12345678910111213141516171819202122function DetailsScreen({route, navigation }:any) { // 获取路由参数 const {itemId, otherParam} = route.params; return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'space-around' }}&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Text&gt;itemId: {JSON.stringify(itemId)}&lt;/Text&gt; &lt;Text&gt;otherParam: {JSON.stringify(otherParam)}&lt;/Text&gt; &lt;Button title=&quot;Set Params&quot; onPress={()=&gt;{ navigation.setParams({ itemId: 'someText' }); }}&gt;&lt;/Button&gt; &lt;Button title=&quot;Go to Details ... again&quot; onPress={() =&gt; navigation.push('Details', { itemId: Math.ceil(Math.random()*100) })} /&gt; &lt;Button title=&quot;Go to Home&quot; onPress={() =&gt; navigation.navigate('Home')} /&gt; &lt;Button title=&quot;Go Back&quot; onPress={() =&gt; navigation.goBack()} /&gt; &lt;Button title=&quot;Go Back to first screen in stack&quot; onPress={() =&gt; navigation.popToTop()}&gt;&lt;/Button&gt; &lt;/View&gt; );} 3.3 初始化参数 您还可以将一些初始参数传递给屏幕。如果您在导航到此屏幕时未指定任何参数，则将使用初始参数。它们也可以与您传递的任何参数浅合并。可以使用 initialParams 属性指定初始参数： 12345&lt;Stack.Screen name=&quot;Details&quot; component={DetailsScreen} initialParams={{ itemId: 42 }}/&gt; 3.4 返回参数给上一个路由 我们将数据通过参数的方式传递给一个新的路由页面，也可以将数据回传给先前的路由页面。例如，有一个路由页面，该页面有一个创建帖子的按钮，这个按钮可以打开一个新的页面来创建帖子，在创建完帖子之后，需要将帖子的一些数据回传给先前的页面。 对于这种需求，我们可以使用 navigation.navigate() 来实现。如果路由在堆栈中已经存在了，他们看起来就像 goBack 一样，只需要将数据绑定到 navigation.navigate() 的 params 中回传给上一页即可，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import * as React from 'react';import { Text, TextInput, View, Button } from 'react-native';import { NavigationContainer } from '@react-navigation/native';import { createStackNavigator } from '@react-navigation/stack';function HomeScreen({ navigation, route }) { React.useEffect(() =&gt; { if (route.params?.post) { // Post updated, do something with `route.params.post` // For example, send the post to the server } }, [route.params?.post]); return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Button title=&quot;Create post&quot; onPress={() =&gt; navigation.navigate('CreatePost')} /&gt; &lt;Text style={{ margin: 10 }}&gt;Post: {route.params?.post}&lt;/Text&gt; &lt;/View&gt; );}function CreatePostScreen({ navigation, route }) { const [postText, setPostText] = React.useState(''); return ( &lt;View&gt; &lt;TextInput multiline placeholder=&quot;What's on your mind?&quot; style={{ height: 200, padding: 10, backgroundColor: 'white' }} value={postText} onChangeText={setPostText} /&gt; &lt;Button title=&quot;Done&quot; onPress={() =&gt; { // Pass params back to home screen navigation.navigate('Home', { post: postText }); }} /&gt; &lt;/View&gt; );}const Stack = createStackNavigator();export default function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator mode=&quot;modal&quot;&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;Stack.Screen name=&quot;CreatePost&quot; component={CreatePostScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );} 当点击 Done 按钮后，Home 页面的 route.params 将会被更新并刷新文本。 3.5 将参数传递给嵌套的导航器 如果涉及有嵌套导航器的场景，则需要以稍微不同的方式传递参数。例如，假设在 Acount 页面嵌套了一个 Settings 页面，并且希望将参数传递到该导航器中的 Settings 页面中，那么可以使用下面的方式。 1234navigation.navigate('Account', { screen: 'Settings', params: { user: 'jane' },}); 3.6 参数中应该包含什么 了解 params 中应该包含什么样的数据很重要。参数就像屏幕的选项。它们应该只包含用于配置屏幕中显示内容的信息。避免传递将显示在屏幕本身上的完整数据（例如传递用户 ID 而不是用户对象）。还要避免传递被多个屏幕使用的数据，这些数据应该放在全局存储中。 你也可以把路由对象想象成一个 URL。如果您的屏幕有一个 URL，那么 URL 中应该包含什么？参数不应包含您认为不应出现在 URL 中的数据。这通常意味着您应该使用尽可能少的数据来确定屏幕是什么。想想访问一个购物网站，当您看到产品列表时，URL 通常包含类别名称、排序类型、过滤字段等，它不包含在屏幕上实际显示的产品列表。 例如，假设您有一个 Profile 屏幕。导航到它时，您可能会想在参数中传递用户对象： 123456789// Don't do thisnavigation.navigate('Profile', { user: { id: 'jane', firstName: 'Jane', lastName: 'Done', age: 25, },}); 这看起来很方便，让您的 route.params.user 无需任何额外工作即可访问用户对象。 然而，这是一种反模式。诸如用户对象之类的数据应该在您的全局存储中而不是在导航状态中。否则，您会在多个地方复制相同的数据。这可能会导致错误，例如即使用户对象在导航后发生了更改，Profile 屏幕也会显示过时的数据。 通过深层链接或者在 Web 上链接到屏幕时也会出现问题，因为： URL 是屏幕的表示，因此还需要包含参数，即完整的用户对象，这会使 URL 非常长且不可读 由于用户对象在 URL 中，因此有可能传递一个随机用户对象来代表一个不存在的用户，或者在配置文件中有不正确的数据 如果用户对象没有被传递，或者格式不正确，这可能会导致崩溃，因为屏幕不知道该如何处理它 更好的方法是在 params 中只传递用户的 ID： 1navigation.navigate('Profile', { userId: 'jane' }); 现在，您可以使用传递的 userId 从您的全局存储中获取用户。这消除了许多问题，例如过时的数据或有问题的 URL。 参数中应该包含的内容的一些示例： 用户 ID、商品 ID 等 ID，例如 navigation.navigate('Profile', { userId: 'Jane' }) 当您有项目列表时，用于排序、过滤数据等的参数，例如 navigation.navigate('Feeds', { sortBy: 'latest' }) 用于分页的时间戳、页码或光标，例如 navigation.navigate('Chat', { beforeTime: 1603897152675 }) 填充屏幕上的输入以组成某些东西的数据，例如 navigation.navigate('ComposeTweet', { title: 'Hello world!' }) 本质上，在 params 中传递识别屏幕所需的最少数据，在很多情况下，这只是意味着传递对象的 ID 而不是传递完整的对象。 将您的应用程序数据与导航状态分开。 导航栏配置4.1 设置导航栏标题 React Navigation 的 Screen 组件有一个 options 属性，这个属性包含了很多可配置的选项，例如设置导航栏的标题，如下所示。 1234567891011function StackScreen() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ title: 'My home' }} /&gt; &lt;/Stack.Navigator&gt; );} 4.2 在标题中使用参数 为了在标题中使用参数，我们可以把 options 属性定义为一个返回配置对象的方法。即我们可以将 options 定义为一个方法，React Navigation 调用它并为其传入两个可供使用的参数{navigation,route} 即可，如下所示。 123456789101112131415161718192021222324252627282930313233343536function HomeScreen({ navigation, route }:any) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Button title=&quot;Set Profile Name&quot; onPress={() =&gt; { navigation.navigate('Profile', { name: &quot;我来即我见&quot;}) }} /&gt; &lt;/View&gt; );}function ProfileScreen({ navigation, route }:any) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Profile Screen&lt;/Text&gt; &lt;/View&gt; )}function StackScreen() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ title: 'My home' }} /&gt; &lt;Stack.Screen name=&quot;Profile&quot; component={ProfileScreen} options={({ route }:any) =&gt; ({ title: route.params.name })} /&gt; &lt;/Stack.Navigator&gt; );} navigation：屏幕组件的 navigation 属性 route：屏幕组件的 route 属性 4.3 使用 setOptions 更新 options 有时候，我们需要在一个已加载的屏幕组件上更新它的 options 配置，对于这样的需求，我们可以使用 navigation.setOptions() 来实现。 1234&lt;!-- Inside of render() of React class --&gt;&lt;Button title=&quot;Update the title&quot; onPress={() =&gt; navigation.setOptions({ title: 'Updated!' })}/&gt; 4.4 设置导航栏的样式 React Navigation支持自定义导航头的样式，我们可以使用如下三个样式属性 headerStyle、headerTintColor 和 headerTitleStyle，含义如下： headerStyle：用于设置包裹住导航头的视图样式，比如为导航栏设置背景色。 headerTintColor：回退按钮和title都是使用这个属性来设置他们的颜色。 headerTitleStyle：如果需要自定义字体、字体粗细和其他文本样式，可以使用属性。 1234567891011121314151617181920function StackScreen() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ title: 'My home', headerStyle: { backgroundColor: '#f4511e', }, headerTintColor: '#fff', headerTitleStyle: { fontWeight: 'bold', }, }} /&gt; &lt;/Stack.Navigator&gt; );} 自定义导航栏样式的时候，有以下几点需要注意： 在IOS上，状态栏文本和图标是黑色的，所以你将背景色设置为暗色的话可能看起来不是很好。 以上的设置仅仅只在 Home 页面有效，当我们跳转到 Details 页面的时候，依然会显示默认的颜色。 4.5 与其他屏幕组件共享 options 参数 有时候，我们需要多个页面设置相同的导航头样式。那么，我们可以使用堆栈导航器的 screenOptions 属性。 12345678910111213141516171819function StackScreen() { return ( &lt;Stack.Navigator screenOptions={{ headerStyle: { backgroundColor: '#f4511e', }, headerTintColor: '#fff', headerTitleStyle: { fontWeight: 'bold', }, }} &gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ title: 'My home' }} /&gt; &lt;/Stack.Navigator&gt; );} 在上面的例子中，任何属于 StackScreen 的页面都将使用相同样式的导航头。 4.6 自定义组件替换 title 属性 有时候，我们想对 title 做更多的设置，比如使用一张图片来替换 title 的文字，或者将 title 放进一个按钮中，这些场景中我们完全可以使用自定义的组件来覆盖 title，如下所示。 12345678910111213141516171819function LogoTitle() { return ( &lt;Image style={{ width: 50, height: 50 }} source={require('@expo/snack-static/react-native-logo.png')} /&gt; );}function StackScreen() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ headerTitle: props =&gt; &lt;LogoTitle {...props} /&gt; }}/&gt; &lt;/Stack.Navigator&gt; );} 导航栏按钮5.1 为导航栏添加按钮 通常，我们可以使用导航头的按钮来实现路由操作。比如，我们点击导航栏左边的按钮可以返回上一个路由，点击导航头的右边可以进行其他操作，如下所示。 12345678910111213141516171819202122import { Alert } from 'react-native';function StackScreen() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ headerTitle: props =&gt; &lt;LogoTitle {...props} /&gt;, headerRight: () =&gt; ( &lt;Button onPress={() =&gt; Alert.alert('This is a button!')} title=&quot;Info&quot; color=&quot;#fff&quot; /&gt; ), }} /&gt; &lt;/Stack.Navigator&gt; );} 5.2 导航头与屏幕组件交互 只需要使用 navigation.setOptions() 即可实现按钮与屏幕组件的交互，可以使用 navigation.setOptions() 来访问 screen 组件的属性如 props，state 和 context 等。 123456789101112131415161718192021222324252627function StackScreen() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={({ navigation, route }) =&gt; ({ headerTitle: props =&gt; &lt;LogoTitle {...props} /&gt;, })} /&gt; &lt;/Stack.Navigator&gt; );}function HomeScreen({ navigation }) { const [count, setCount] = React.useState(0); React.useLayoutEffect(() =&gt; { navigation.setOptions({ headerRight: () =&gt; ( &lt;Button onPress={() =&gt; setCount(c =&gt; c + 1)} title=&quot;Update count&quot; /&gt; ), }); }, [navigation]); return &lt;Text&gt;Count: {count}&lt;/Text&gt;;} 5.3 自定义返回按钮 createStackNavigator 提供了平台默认的返回按钮，在 iOS 平台上，在按钮的旁边会有一个标签，这个标签会显示上一页标题的缩写，上一页没有标题就显示一个Back字样。 开发者可以通过设置 headerBackTitle 来改变标签文字，设置 headerBackTitleStyle 改变标签的样式，自定页返回按钮图片可以使用 headerBackImageSource 5.4 重写返回按钮 123456789&lt;Screen name=&quot;Home&quot; component={HomeScreen} options={{ headerLeft: (props) =&gt; ( &lt;Button title=&quot;返回&quot; {...props} onPress={()=&gt;Alert.alert('返回上个页面')} /&gt; ) }}/&gt;; 导航器的嵌套导航嵌套指的是一个导航器的导航页中又包含了另一个导航器，例如： 12345678910111213141516171819202122232425262728293031323334353637383940import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'; function FeedScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Feed Screen&lt;/Text&gt; &lt;/View&gt; )}function MessageScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Message Screen&lt;/Text&gt; &lt;/View&gt; )}const Tab = createBottomTabNavigator();function TabsScreen() { return ( &lt;Tab.Navigator&gt; &lt;Tab.Screen name=&quot;Feed&quot; component={FeedScreen} /&gt; &lt;Tab.Screen name=&quot;Message&quot; component={MessageScreen}/&gt; &lt;/Tab.Navigator&gt; )}function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={Home} /&gt; &lt;Stack.Screen name=&quot;Tabs&quot; component={TabsScreen} options={{ headerShown: false }}/&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );} 在上述的例子中，Home 组件包含了一个 Tab 导航器。同时，这个 Home 组件也是 Stack 导航器中的一个导航页，从而形成了一个导航嵌套的场景。 导航器的嵌套其实跟我们通常使用的组件的嵌套类似，一般情况下，我们会嵌套多个导航器。 6.1 如何实现导航器嵌套 实现导航器嵌套时，有以下几点需要特别注意： （1）每个导航器管理它自己的导航栈 比如，当你在一个被嵌套的堆栈导航器中点击返回按钮的时候，它会返回到本导航器（也就是被嵌套的堆栈导航器）导航历史中的上一页，而不是返回到上级导航器中。 （2）每个导航器管理它自己的 options 比如，当你在被嵌套的子导航器的屏幕中设置 title 选项时，不会影响父导航器中显示的标题。 如果你想要在堆栈导航器中显示被嵌套的选项卡导航器处于活跃状态的屏幕的 title，请参考指南 screen options with nested navigators （3）导航器中的每个屏幕管理它自己的参数 任何传递给在嵌套导航器中的屏幕的 params 都在此屏幕的 route prop 中，并且不能被来自父导航器与子导航器中的屏幕访问 如果你需要在子导航器屏幕中访问父导航器屏幕中的参数，你可以使用 React Context 将参数暴露给子导航器屏幕 （4）导航动作将会被当前导航器处理，如果不能处理，它将会冒泡 比如，你在被嵌套导航器的屏幕中调用 navigation.goBack()，只有你已经是当前导航器的第一个屏幕时，才会在父导航器中返回到上一页。其他操作诸如 navigate 也是类似的，导航将会在嵌套导航器中发生，如果嵌套导航器不能够处理，那么父导航器将会尝试处理它。在上面的例子中，当我们调用 navigation.navigate('Message') ，在 Feed 屏幕当中，被嵌套的 Tab 导航器将会处理它；但是如果你调用 navigation.navigate('Home')，父导航器将会处理它 （5）导航器的一些特定方法在子导航器中同样可用 在 Drawer 导航器中嵌套了一个 Stack 导航器，那么 Drawer 导航器的 openDrawer、closeDrawer 方法在被嵌套的 Stack 导航器的 navigation 属性中依然是可用的。但是如果 Stack 导航器没有嵌套在 Drawer 导航器中，那么这些方法是不可访问的。 同样，如果你在 Stack 导航器中嵌套了一个 Tab 导航器，那么 Tab 导航器的 navigation 属性中会新得到 push 和 replace 这两个方法。 如果你需要从父级分发动作给被嵌套的子导航器，你可以使用 navigation.dispatch() 1navigation.dispatch(DrawerActions.toggleDrawer()); （6）被嵌套的导航器不会响应父级导航器的事件 如果 Stack 导航器被嵌套在 Tab 导航器中，那么 Stack 导航器的页面不会响应由父 Tab 导航器触发的事件，比如我们使用 navigation.addListener() 绑定的 tabPress 事件。为了能够响应父级导航器的事件，我们可以使用 navigation.getParent() 来监听父级导航器的事件。 123const unsubscribe = navigation.getParent().addListener('tabPress', (e) =&gt; { // Do something}); （7）父级导航器先于子导航器被渲染 对于上面的这句话，我们怎么理解呢？在 Drawer 导航器中嵌套了一个 Stack 导航器，你会看到抽屉的效果先被渲染出来，接着才是渲染 Stack 导航器的头部，但是如果将 Drawer 导航器嵌套在 Stack 导航器中，那么则会先渲染Stack 导航器的头部再渲染抽屉效果。因此，我们可以根据这一现象来确认我们需要选择哪种导航器的嵌套。 在你的 App 里面，你可能会根据你想要的行为使用这些模式 Tab 导航器嵌套在 Stack 导航器的初始屏幕中 - 当你 push 新屏幕时将会覆盖 Tab bar Drawer 导航器嵌套在 Stack 导航器的初始屏幕中，初始屏幕的 Stack header 隐藏 - Drawer 只能从 Stack 的第一个屏幕中打开 Stack 导航器被嵌套在 Drawer 导航器的每个屏幕中 - Drawer 出现在 Stack header 上方 Stack 导航器被嵌套在 Tab 导航器的每个屏幕中 - Tab bar 始终可见。 通常按下 Tab，将会调用 navigation.popToTop() 6.2 嵌套路由的跳转 我们先来看一下下面这段代码。 123456789101112131415161718192021222324function Root() { return ( &lt;Drawer.Navigator&gt; &lt;Drawer.Screen name=&quot;Home&quot; component={Home} /&gt; &lt;Drawer.Screen name=&quot;Profile&quot; component={Profile} /&gt; &lt;Stack.Screen name=&quot;Settings&quot; component={Settings} /&gt; &lt;/Drawer.Navigator&gt; );}function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Root&quot; component={Root} options={{ headerShown: false }} /&gt; &lt;Stack.Screen name=&quot;Feed&quot; component={Settings} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );} 假如，现在想从 Feed 页面中跳转到 Root 页面，那么我们可以使用下面的方式 1navigation.navigate('Root'); 它生效了，并且显示 Root 组件内部的初始屏幕，即 Home，不过，有时你可能希望显示自己指定的页面，为了实现这个功能，可以在参数中携带页面的名字，如下所示。 1navigation.navigate('Root',{screen: 'Profile'}}); 此时，将呈现 Proilfe 屏幕 这可能看起来与以前的用于嵌套屏幕的导航方式大不相同。不同之处在于，在之前的版本中，所有配置都是静态的，因此 React Navigation 可以通过递归嵌套配置来静态查找所有导航器及其屏幕。但是现在通过动态配置，React Navigation 不知道哪些屏幕可用以及在哪里，直到包含屏幕的导航器呈现。通常，屏幕在您导航到它之前不会呈现其内容，因此尚未呈现的导航器配置尚不可用。这使得有必要指定您要导航到的层次结构。这也是为什么您应该尽可能少地嵌套导航器以保持代码简洁。 6.2.1 传递参数给被嵌套导航中的屏幕 1234navigation.navigate('Root', { screen: 'Profile', params: { user: 'jane' }}); 如果导航器已经被渲染，导航到另一个屏幕将在堆栈导航器中压入一个新屏幕 对于深度嵌套的屏幕，可以采用类似的方法。请注意，navigate 此处的第二个参数是 params，因此您可以执行以下操作： 123456789navigation.navigate('Root', { screen: 'Settings', params: { screen: 'Sound', params: { screen: 'Media', }, },}); 在上述情况下，您将导航到 Media 屏幕，它位于嵌套在 Sound 屏幕内的导航器中，而导航器位于嵌套在 Settings 屏幕内的导航器中。 6.2.2 显示在导航器中定义的初始屏幕 ？？？（自己验证并没有作用） 默认情况下，当您在嵌套导航器中导航屏幕时，指定的屏幕将用作初始屏幕，并且导航器上的初始路由 prop 将被忽略。这种行为不同于 React Navigation 4。 如果您需要渲染导航器中指定的初始路由，您可以通过设置 initial: false 禁用使用指定屏幕作为初始屏幕的行为： 1234navigation.navigate('Root', { screen: 'Settings', initial: false}); 这将会影响到按下后退按钮时发生的情况。当有初始屏幕时，后退按钮会将用户带到那里。？？？ 6.3 嵌套多个导航器 嵌套多个导航器（例如堆栈、抽屉或选项卡）有时很有用。 当嵌套多个堆栈、抽屉或底部选项卡导航器时，将显示来自子导航器和父导航器的标题。但是，通常更希望在子导航器中显示标题并在父导航器的屏幕中隐藏标题。 为此，您可以使用该 headerShown: false 选项隐藏包含导航器的屏幕中的标题。 例如： 1234567891011121314151617181920212223function Home() { return ( &lt;Tab.Navigator&gt; &lt;Tab.Screen name=&quot;Profile&quot; component={Profile} /&gt; &lt;Tab.Screen name=&quot;Settings&quot; component={Settings} /&gt; &lt;/Tab.Navigator&gt; );}function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={Home} options={{ headerShown: false }} /&gt; &lt;Stack.Screen name=&quot;EditPost&quot; component={EditPost} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );} 在这些示例中，我们使用了直接嵌套在另一个堆栈导航器内部的底部选项卡导航器，但是当中间有其他导航器时，原则同样适用，例如：堆栈导航器位于另一个堆栈导航器内部的选项卡导航器中，或者堆栈导航器内部的抽屉导航器等 如果您不想在任何导航器中显示标题，可以使用 headerShown: false 在所有导航器中指定： 6.4 嵌套时的最佳实践 我们建议将嵌套导航器减少到最少。尝试以尽可能少的嵌套来实现您想要的操作。嵌套有很多缺点： 它导致了深度嵌套的视图层次结构，这可能会导致低端设备出现内存和性能问题 嵌套相同类型的导航器（例如选项卡内的选项卡、抽屉内的抽屉等）可能会导致用户体验混乱 由于嵌套过多，在导航到嵌套屏幕、配置深层链接等时，代码变得难以理解。 将嵌套导航器视为实现所需 UI 的一种方式，而不是一种组织代码的方式。如果要为组织创建单独的屏幕组，而不是使用单独的导航器，则可以使用 Group 组件。 1234567891011121314151617181920&lt;Stack.Navigator&gt; {isLoggedIn ? ( // Screens for logged in users &lt;Stack.Group&gt; &lt;Stack.Screen name=&quot;Home&quot; component={Home} /&gt; &lt;Stack.Screen name=&quot;Profile&quot; component={Profile} /&gt; &lt;/Stack.Group&gt; ) : ( // Auth screens &lt;Stack.Group screenOptions={{ headerShown: false }}&gt; &lt;Stack.Screen name=&quot;SignIn&quot; component={SignIn} /&gt; &lt;Stack.Screen name=&quot;SignUp&quot; component={SignUp} /&gt; &lt;/Stack.Group&gt; )} {/* Common modal screens */} &lt;Stack.Group screenOptions={{ presentation: 'modal' }}&gt; &lt;Stack.Screen name=&quot;Help&quot; component={Help} /&gt; &lt;Stack.Screen name=&quot;Invite&quot; component={Invite} /&gt; &lt;/Stack.Group&gt;&lt;/Stack.Navigator&gt; 导航器的生命周期在前面的内容中，我们介绍了React Navigation的一些基本用法，以及路由跳转相关的内容。但是，我们并不知道路由是如何实现页面的跳转和返回的。 如果你对前端Web比较熟悉的话，那么你就会发现当用户从路由A跳转到路由B的时候，A将会被卸载（componentWillUnmount方法会被调用）当用户从其他页面返回A页面的时候，A页面又会被重新加载。React 的生命周期方法在React Navigation中仍然有效，不过相比Web的用法不尽相同，且移动端导航更为复杂。 7.1 Example 假设有一个 Stack 导航器，里面有A、B两个页面。从其他页面跳转到A页面(navigation.navigate('A'))，它的componentDidMount将会被调用。从A页面跳转到B页面(navigation.push('B'))，B页面的compouentDidMount也会被调用，但是A页面始终在堆栈中保持被加载的状态，因此A页面的componentWillUnmount不会被调用。 但是，当我们从B页面返回到A页面的时候，B页面的compouentWillUnmount则会被调用，但是A页面的componentDidMount不会被调用，因为其没有被卸载，在整个过程中一直保持着被加载的状态。 在其他类型的导航器中也是相同的结果，假设有一个 Tab 导航器，其有两个 Tab，每个 Tab 都是一个 Stack 导航器。 123456789101112131415161718192021222324252627function App() { return ( &lt;NavigationContainer&gt; &lt;Tab.Navigator&gt; &lt;Tab.Screen name=&quot;First&quot;&gt; {() =&gt; ( &lt;SettingsStack.Navigator&gt; &lt;SettingsStack.Screen name=&quot;Settings&quot; component={SettingsScreen} /&gt; &lt;SettingsStack.Screen name=&quot;Profile&quot; component={ProfileScreen} /&gt; &lt;/SettingsStack.Navigator&gt; )} &lt;/Tab.Screen&gt; &lt;Tab.Screen name=&quot;Second&quot;&gt; {() =&gt; ( &lt;HomeStack.Navigator&gt; &lt;HomeStack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;HomeStack.Screen name=&quot;Details&quot; component={DetailsScreen} /&gt; &lt;/HomeStack.Navigator&gt; )} &lt;/Tab.Screen&gt; &lt;/Tab.Navigator&gt; &lt;/NavigationContainer&gt; );} 首先从 HomeScreen 跳转到 DetailsScreen ，然后切换底部选项卡，从 SettingScreen 跳转到 ProfileScreen。在这一系列操作完成之后，所有的四个页面都已经被加载过了，如果你切换底部选项卡回到HomeStack，你会发现当前呈现的还是 DetailsScreen（HomeStack的导航状态已经被保存了） 7.2 React Navigation 生命周期事件 现在我们知道生命周期函数在 React Navigation 中是如何工作的了，让我们回答我们一开始提出的问题：”我们是如何发现用户离开当前页面和返回当前页面的？” React Navigation 将会发布事件给订阅这些事件的屏幕组件，我们可以监听 focus 和 blur 事件，来了解当前页面是否被激活 123456789101112function Profile({ navigation }) { React.useEffect(() =&gt; { const unsubscribe = navigation.addListener('focus', () =&gt; { // Screen was focused // Do something }); return unsubscribe; }, [navigation]); return &lt;ProfileContent /&gt;;} 我们可以使用 useFocusEffect 钩子监听生命周期来替代手动添加监听器，它类似于 React 的 useEffect 钩子，不同的是，useFocusEffect 只能监听导航的生命周期 12345678910111213141516import { useFocusEffect } from '@react-navigation/native';function Profile() { useFocusEffect( React.useCallback(() =&gt; { // Do something when the screen is focused return () =&gt; { // Do something when the screen is unfocused // Useful for cleanup functions }; }, []) ); return &lt;ProfileContent /&gt;;} 如果你想要根据页面是否获得焦点和失去焦点来渲染不同的东西，也可以调用 useIsFocused 钩子，useIsFocused 会返回一个布尔值，用来指示该页面是否获得了焦点。 总的来说，React 的生命周期方法仍然可用，除此之外，React Navigation又增加了更多的事件方法，开发者可以通过 navigation 属性来订阅他们。并且，开发者可以使用 useFocusEffect 或者 useIsFocused 钩子。 打开一个 Modal 全面屏页面在 React Native 中，Modal 是一个弹窗组件，它不是导航中的页面，因此其显示与隐藏都有其独特的方式，我们可以使用它展示一些特别的提示信息。 8.1 创建一个Modal 堆栈导航器 首先，我们来看一下如下一段代码： 只在 iOS 中可用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function HomeScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text style={{ fontSize: 30 }}&gt;This is the home screen!&lt;/Text&gt; &lt;Button onPress={() =&gt; navigation.navigate('MyModal')} title=&quot;Open Modal&quot; /&gt; &lt;/View&gt; );} function DetailsScreen() { return ( &lt;View&gt; &lt;Text&gt;Details&lt;/Text&gt; &lt;/View&gt; );} function ModalScreen({ navigation }) { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text style={{ fontSize: 30 }}&gt;This is a modal!&lt;/Text&gt; &lt;Button onPress={() =&gt; navigation.goBack()} title=&quot;Dismiss&quot; /&gt; &lt;/View&gt; );} const MainStack = createNativeStackNavigator();const RootStack = createNativeStackNavigator(); function MainStackScreen() { return ( &lt;MainStack.Navigator&gt; &lt;MainStack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;MainStack.Screen name=&quot;Details&quot; component={DetailsScreen} /&gt; &lt;/MainStack.Navigator&gt; );} function RootStackScreen() { return ( &lt;RootStack.Navigator screenOptions={{presentation: 'modal'}}&gt; &lt;RootStack.Screen name=&quot;Main&quot; component={MainStackScreen} options={{ headerShown: false }} /&gt; &lt;RootStack.Screen name=&quot;MyModal&quot; component={ModalScreen} /&gt; &lt;/RootStack.Navigator&gt; );} 首先，我们来看一下上面示例中导航器的示意图。 在上面的示例中，我们使用 MainStackScreen 作为 RootStackScreen 的屏幕组件，就相当于我们在一个堆栈导航器中嵌入了另一个堆栈导航器。因此，当我们运行项目时，RootStackScreen 会渲染一个堆栈导航器，该导航器有自己的头部，当然我们也可以将这个头部隐藏。 堆栈导航器的 presentation 属性值可以是 card(默认)或者modal。在 iOS 上，modal 的展现方式是从底部滑入，退出的时候则是从上往下滑的方式来关闭它。在 Android 上，modal 是无效的属性，因为全面屏的 modal 与android 的平台自带的行为没有任何区别。 Modal 堆栈导航器在 React Navigation 导航中是非常有用的，如果你想变更堆栈导航器页面的过渡动画，那么就可以使用 presentation 属性。当将其设置为 modal 时，所有屏幕转换之间的过渡动画就会变为从底部滑到顶部，而不是原先的从右侧滑入。但是，需要注意的是，React Navigation 的 modal 会对整个堆栈导航器起效，所以为了在其他屏幕上使用从右侧滑入的效果，我们可以再另外添加一个导航器，这个导航器使用默认的配置就行。 名称解释9.1 Navigator Navigator 是一个 React 组件，它决定应用以哪种方式展现已定义的页面。NavigationContainer 则是一个管理导航树并包含导航状态的组件，该组件是所有导航器组件的父容器，包装了所有导航器的结构。通常，我们需要将NavigationContainer 组件放在应用程序的根目录下，作为启动的根文件（App.js）。 12345678910function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; ); // &lt;---- This is a Navigator} 9.2 Router Router 即是路由器，它是一组函数，它决定如何在导航器中处理用户的操作和状态的更改，通常，开发者不需要直接参与路由器交互，除非您需要编写自定义导航器。 9.3 Screen component Screen component 即屏幕组件，是我们在路由配置中需要跳转的组件。 123456789101112const Stack = createStackNavigator();const StackNavigator = ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt; &lt;Stack.Screen name=&quot;Details&quot; component={DetailsScreen} /&gt; &lt;/Stack.Navigator&gt;); 需要注意的是，只有当屏幕被 React Navigation 呈现为一个路由时才能实现跳转功能。例如，如果我们渲染DetailsScreen 作为主屏幕的子元素，那么 DetailsScreen 将不会提供导航道具，当你在主屏幕上按下 “Go to Details…” 按钮时应用程序会抛出 “undefined is not an object “ 的错误。 123456789101112function HomeScreen() { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details&quot; onPress={() =&gt; navigation.navigate('Details')} /&gt; &lt;DetailsScreen /&gt; &lt;/View&gt; );} 9.4 Navigation Prop 通过使用 Navigation 提供的属性，我们可以在两个页面之间传递数据，常用的属性如下 dispatch： 向路由发送一个 action navigate，goBack：打开或者返回页面 9.5 Navigation State 导航器的状态如下所示 12345678{ key: 'StackRouterRoot', index: 1, routes: [ { key: 'A', name: 'Home' }, { key: 'B', name: 'Profile' }, ]} 9.6 Route Prop Route 提供的属性，可以被传递给所有的屏幕。包含有关当前 route 的信息，例如 params，key 和 name 9.7 Route 每个路由都是一个对象，其中包含标识它的键和指定路由类型的“名称”，并且还可以包含任意类型的参数。 12345{ key: 'B', name: 'Profile', params: { id: '123' }} 9.8 Header 也称为导航标题、导航栏、应用栏，可能还有许多其他东西。这是屏幕顶部的矩形，包含后退按钮和屏幕标题。 整个矩形在 React Navigation 中通常称为标题。 参考博文： React Navigation 5.x详解 - SegmentFault 思否 (30条消息) react-navigation导航组件使用详解_栀夏暖阳的博客-CSDN博客_react 导航 Getting started | React Navigation","link":"/2021/12/24/React-Navigation-6-x-%E6%96%87%E6%A1%A3%E7%AE%80%E8%BF%B0/"}],"tags":[{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"Ionic5.x","slug":"Ionic5-x","link":"/tags/Ionic5-x/"},{"name":"Capacitor","slug":"Capacitor","link":"/tags/Capacitor/"},{"name":"Vue3.x","slug":"Vue3-x","link":"/tags/Vue3-x/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"极光推送","slug":"极光推送","link":"/tags/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"时间机器","slug":"时间机器","link":"/tags/%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8/"},{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"Code Push","slug":"Code-Push","link":"/tags/Code-Push/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"nvm","slug":"nvm","link":"/tags/nvm/"},{"name":"布局方式","slug":"布局方式","link":"/tags/%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"},{"name":"HTML&amp;&amp;CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"React Navigation","slug":"React-Navigation","link":"/tags/React-Navigation/"}],"categories":[{"name":"桌面端开发","slug":"桌面端开发","link":"/categories/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"移动端开发","slug":"移动端开发","link":"/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"代码版本管理","slug":"代码版本管理","link":"/categories/%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"前端工程化","slug":"前端工程化","link":"/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"前端基础","slug":"前端基础","link":"/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]}